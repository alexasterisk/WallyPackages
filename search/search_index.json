{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Collection of Wally Packages Packages v0.1.2 import v0.1.2 switch-case v0.1.0 lua-class v2.3.2 quenty/maid","title":"Home"},{"location":"#collection-of-wally-packages","text":"","title":"Collection of Wally Packages"},{"location":"#packages","text":"v0.1.2 import v0.1.2 switch-case v0.1.0 lua-class v2.3.2 quenty/maid","title":"Packages"},{"location":"import/","text":"Introduction Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . For starters, you'll need to know how to use Roblox Studio... ~and Luau~... Anyways, Import is a Require module like TypeScript's import . Sugar No Sugar local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"shared/someClass\" local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import ( \"shared/someClass\" ) Sugar Syntax Due to Lua's weird sugar syntax rules when it comes to encapsulation: You can create this weird syntax which drives some people insane but I personally think it looks cool. This is inspired off of Elttob's Fusion module .","title":"Introduction"},{"location":"import/#introduction","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . For starters, you'll need to know how to use Roblox Studio... ~and Luau~... Anyways, Import is a Require module like TypeScript's import . Sugar No Sugar local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"shared/someClass\" local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import ( \"shared/someClass\" )","title":"Introduction"},{"location":"import/#sugar-syntax","text":"Due to Lua's weird sugar syntax rules when it comes to encapsulation: You can create this weird syntax which drives some people insane but I personally think it looks cool. This is inspired off of Elttob's Fusion module .","title":"Sugar Syntax"},{"location":"import/installation/","text":"Installation Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Installing Import is as simple as simple as I could've ever made it. It's necessary to install it via your prefered method. Using Rojo If you use Rojo, this is relatively easy by setting up your Rojo workflow like the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SomeRandomPackage = \"notAlex/notImport@1.0.0\" Import = \"alexinite/import@0.1.2\" default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" }, \"DevPackages\" : { \"$path\" : \"DevPackages\" } }, \"ServerScriptService\" : { \"$path\" : \"src/server\" , \"Packages\" : { \"$path\" : \"ServerPackages\" } } ... } } After that, you just have to run wally install in your project's directory. Using GitHub For those that use GitHub, you will to download the .zip file on the repository and copy the entire folder of src/Import into the Packages folder in ReplicatedStorage.","title":"Installation"},{"location":"import/installation/#installation","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Installing Import is as simple as simple as I could've ever made it. It's necessary to install it via your prefered method.","title":"Installation"},{"location":"import/installation/#using-rojo","text":"If you use Rojo, this is relatively easy by setting up your Rojo workflow like the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SomeRandomPackage = \"notAlex/notImport@1.0.0\" Import = \"alexinite/import@0.1.2\" default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" }, \"DevPackages\" : { \"$path\" : \"DevPackages\" } }, \"ServerScriptService\" : { \"$path\" : \"src/server\" , \"Packages\" : { \"$path\" : \"ServerPackages\" } } ... } } After that, you just have to run wally install in your project's directory.","title":"Using Rojo"},{"location":"import/installation/#using-github","text":"For those that use GitHub, you will to download the .zip file on the repository and copy the entire folder of src/Import into the Packages folder in ReplicatedStorage.","title":"Using GitHub"},{"location":"import/usage/","text":"Usage Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Reference Points Referencing using import is in close parity with TypeScript's import from and formatted around Rojo's traditional workflow. It's also worth to note that the first letter of what you're requiring is interchangeable with uppercase and lowercase. Wally Packages When Importing packages from Wally, you will need your Rojo workflow to look like the following: default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" }, \"DevPackages\" : { \"$path\" : \"DevPackages\" } }, \"ServerScriptService\" : { \"$path\" : \"src/server\" , \"Packages\" : { \"$path\" : \"ServerPackages\" } } ... } } Then, after installing with wally install , you can require a Wally package like this: Example 1 2 3 local import = require ( game . ReplicatedStorage . Packages . Import ) local Maid = import \"@wally/maid\" Tip If you're importing a dev-package or server-package, it can be done like this: local devPackage = import \"@wally-dev/someDevPackage\" local serverPackage = import \"@wally-server/someServerPackage\" ReplicatedStorage Example local SomeClass = import \"shared/classModule\" StarterPlayerScripts Example *.client.lua local SomeClass = import \"client/classModule\" Client-Only Using client/ can only be done in a client-sided context. Attempting to access it from a server-sided context will result in an error. ServerScriptService Example *.server.lua local SomeClass = import \"server/classModule\" Server-Only Using server/ can only be done in a server-sided context. Attempting to access it from a client-sided context will result in an error. Dot References One thing to tackle with this project was allowing TypeScript's ./ and ../ to be available from all contexts. Mostly for use with submodules. Example 1 2 3 4 local import = require ( game . ReplicatedStorage . Packages . Import ) [ script ] local SomeSubclass = import \"./subclass\" local ClassInSameDir = import \"../otherClass\" Don't forget to set [script] Forgetting [script] when requiring import in times where a dot reference is used will result in an error. Table and Function Back Referencing Whenever you require a Module you lose the ability to access the ModuleScript as an Instance without reusing the same location. Here is an example ModuleScript: Example shared/Multiply.lua 1 2 3 return function ( x : number , y : number ) return x * y end Now, this is a comparison of how you would back reference in Import and Roblox's default Require: Import Require local multiply = import \"shared/multiply\" -- first letter can be lowercase for consistency print ( multiply ( 5 * 3 )) -- prints 15 print ( multiply : GetFullName ()) -- \"game.ReplicatedStorage.Multipy\" local multiplyInstance = ReplicatedStorage . Mulitply local multiply = require ( multiplyInstance ) print ( multiply ( 5 * 3 )) -- prints 15 print ( multiplyInstance : GetFullName ()) -- \"game.ReplicatedStorage.Multiply\" This is also similar for tables/metatables kind of . Example shared/RandomClass.lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local class = {} class . __index = class function class . new ( x : number ) return setmetatable ({ number = x }, class ) end function class : multiplyBy ( y : number ) return self . number * y end return class local RandomClass = import \"shared/randomClass\" local randomClass = RandomClass . new ( 5 ) print ( randomClass : multiplyBy ( 3 )) -- prints 15 print ( randomClass . importBackRef : GetFullName ()) -- \"game.ReplicatedStorage.RandomClass\" Referencing Instances Sometimes what you're searching for doesn't need to be a script. Like the following: Example shared/part.model.json { \"ClassName\" : \"Part\" , \"Children\" : [{ \"Name\" : \"Head\" , \"ClassName\" : \"Part\" }], \"Properties\" : { \"Anchored\" : true } } local part = import \"shared/part\" print ( part . Head : GetFullName ()) -- \"game.ReplicatedStorage.part.Head\" Severely Impractical The implications of using Import like this is more impractical than using Import itself: which is impractical. You really needed me to tell you that?","title":"Usage"},{"location":"import/usage/#usage","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to .","title":"Usage"},{"location":"import/usage/#reference-points","text":"Referencing using import is in close parity with TypeScript's import from and formatted around Rojo's traditional workflow. It's also worth to note that the first letter of what you're requiring is interchangeable with uppercase and lowercase.","title":"Reference Points"},{"location":"import/usage/#wally-packages","text":"When Importing packages from Wally, you will need your Rojo workflow to look like the following: default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" }, \"DevPackages\" : { \"$path\" : \"DevPackages\" } }, \"ServerScriptService\" : { \"$path\" : \"src/server\" , \"Packages\" : { \"$path\" : \"ServerPackages\" } } ... } } Then, after installing with wally install , you can require a Wally package like this: Example 1 2 3 local import = require ( game . ReplicatedStorage . Packages . Import ) local Maid = import \"@wally/maid\" Tip If you're importing a dev-package or server-package, it can be done like this: local devPackage = import \"@wally-dev/someDevPackage\" local serverPackage = import \"@wally-server/someServerPackage\"","title":"Wally Packages"},{"location":"import/usage/#replicatedstorage","text":"Example local SomeClass = import \"shared/classModule\"","title":"ReplicatedStorage"},{"location":"import/usage/#starterplayerscripts","text":"Example *.client.lua local SomeClass = import \"client/classModule\" Client-Only Using client/ can only be done in a client-sided context. Attempting to access it from a server-sided context will result in an error.","title":"StarterPlayerScripts"},{"location":"import/usage/#serverscriptservice","text":"Example *.server.lua local SomeClass = import \"server/classModule\" Server-Only Using server/ can only be done in a server-sided context. Attempting to access it from a client-sided context will result in an error.","title":"ServerScriptService"},{"location":"import/usage/#dot-references","text":"One thing to tackle with this project was allowing TypeScript's ./ and ../ to be available from all contexts. Mostly for use with submodules. Example 1 2 3 4 local import = require ( game . ReplicatedStorage . Packages . Import ) [ script ] local SomeSubclass = import \"./subclass\" local ClassInSameDir = import \"../otherClass\" Don't forget to set [script] Forgetting [script] when requiring import in times where a dot reference is used will result in an error.","title":"Dot References"},{"location":"import/usage/#table-and-function-back-referencing","text":"Whenever you require a Module you lose the ability to access the ModuleScript as an Instance without reusing the same location. Here is an example ModuleScript: Example shared/Multiply.lua 1 2 3 return function ( x : number , y : number ) return x * y end Now, this is a comparison of how you would back reference in Import and Roblox's default Require: Import Require local multiply = import \"shared/multiply\" -- first letter can be lowercase for consistency print ( multiply ( 5 * 3 )) -- prints 15 print ( multiply : GetFullName ()) -- \"game.ReplicatedStorage.Multipy\" local multiplyInstance = ReplicatedStorage . Mulitply local multiply = require ( multiplyInstance ) print ( multiply ( 5 * 3 )) -- prints 15 print ( multiplyInstance : GetFullName ()) -- \"game.ReplicatedStorage.Multiply\" This is also similar for tables/metatables kind of . Example shared/RandomClass.lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local class = {} class . __index = class function class . new ( x : number ) return setmetatable ({ number = x }, class ) end function class : multiplyBy ( y : number ) return self . number * y end return class local RandomClass = import \"shared/randomClass\" local randomClass = RandomClass . new ( 5 ) print ( randomClass : multiplyBy ( 3 )) -- prints 15 print ( randomClass . importBackRef : GetFullName ()) -- \"game.ReplicatedStorage.RandomClass\"","title":"Table and Function Back Referencing"},{"location":"import/usage/#referencing-instances","text":"Sometimes what you're searching for doesn't need to be a script. Like the following: Example shared/part.model.json { \"ClassName\" : \"Part\" , \"Children\" : [{ \"Name\" : \"Head\" , \"ClassName\" : \"Part\" }], \"Properties\" : { \"Anchored\" : true } } local part = import \"shared/part\" print ( part . Head : GetFullName ()) -- \"game.ReplicatedStorage.part.Head\" Severely Impractical The implications of using Import like this is more impractical than using Import itself: which is impractical. You really needed me to tell you that?","title":"Referencing Instances"},{"location":"luaclass/","text":"LuaClass LuaClass is an implementation of classes from JavaScript to an extent. This does not include private variables due to Lua's environment. Installation Using Wally LuaClass is available via Wally + Rojo workflow, if you're new to Wally or never heard of it, read about it here ! wally.toml [package] name = \"user/repo\" description = \"some cool project, probably\" version = \"0.1.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Classes = \"alexinite/lua-class@0.1.1\" After doing this (and learning Rojo + Wally, it's worth it I promise!) run wally install on your command line while in your project's repository. Requiring LuaClass will depend on your Rojo project format, for the following examples I will assume you have it like the following, if you've used Wally before you're probably already familiar with this format. *.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Comparison You might be wondering just how much this compares in looks to JavaScript classes or even just regular Roblox metatables, here's your answer: LuaClass Luau Metatables TS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local new , class , extends , meta = require ( game . ReplicatedStorage . Packages . LuaClass )() class \"MathStruct\" { firstValue = 0 ; lastValue = nil ; constructor = function ( this , num : number ) this . firstValue = num return this end , multiply = function ( this , by : number ): number this . lastValue = this . firstValue * by return this . lastValue end , } local mathStruct = new \"MathStruct\" ( 5 ) print ( mathStruct . multiply ( 3 )) -- 15 class \"WithAddition\" [ extends \"MathStruct\" ] { add = function ( this , amount : number ): number this . lastValue = this . firstValue + amount return this . lastValue end , } local withAddition = new \"WithAddition\" ( 7 ) print ( withAddition . multiply ( 3 )) -- 21 print ( withAddition . add ( 13 )) -- 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local MathStruct = {} MathStruct . __index = MathStruct function MathStruct . new ( num : number ) local mt = {} mt . firstValue = num mt . lastValue = nil setmetatable ( mt , MathStruct ) return mt end function MathStruct : multiply ( by : number ): number self . lastValue = self . firstValue * by return self . lastValue end local mathStruct = MathStruct . new ( 5 ) print ( mathStruct : multiply ( 3 )) -- 15 local WithAddition = {} function WithAddition : __index ( index ) return WithAddition [ index ] or MathStruct [ index ] end function WithAddition . new ( num : number ) local mt = {} mt . firstValue = num mt . lastValue = nil setmetatable ( mt , WithAddition ) return mt end function WithAddition : add ( amount : number ): number self . lastValue = self . firstValue + amount return self . lastValue end local withAddition = WithAddition . new ( 7 ) print ( withAddition : multiply ( 3 )) -- 21 print ( withAddition : add ( 13 )) -- 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MathStruct { firstValue : number lastValue : number constructor ( num : number ) { this . firstValue = num ; } multiply ( by : number ) : number { this . lastValue = this . firstValue * by ; return this . lastValue ; } } const mathStruct = new MathStruct ( 5 ); console . log ( mathStruct . multiply ( 3 )); // 15 class WithAddition extends MathStruct { constructor ( num : number ) { super ( num ); } add ( amount : number ) : number { this . lastValue = this . firstValue + amount ; return this . firstValue ; } } const withAddition = new WithAddition (); console . log ( withAddition . multiply ( 3 )); // 21 console . log ( withAddition . add ( 13 )) // 20","title":"Introduction"},{"location":"luaclass/#luaclass","text":"LuaClass is an implementation of classes from JavaScript to an extent. This does not include private variables due to Lua's environment.","title":"LuaClass"},{"location":"luaclass/#installation","text":"","title":"Installation"},{"location":"luaclass/#using-wally","text":"LuaClass is available via Wally + Rojo workflow, if you're new to Wally or never heard of it, read about it here ! wally.toml [package] name = \"user/repo\" description = \"some cool project, probably\" version = \"0.1.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Classes = \"alexinite/lua-class@0.1.1\" After doing this (and learning Rojo + Wally, it's worth it I promise!) run wally install on your command line while in your project's repository. Requiring LuaClass will depend on your Rojo project format, for the following examples I will assume you have it like the following, if you've used Wally before you're probably already familiar with this format. *.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"luaclass/#comparison","text":"You might be wondering just how much this compares in looks to JavaScript classes or even just regular Roblox metatables, here's your answer: LuaClass Luau Metatables TS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local new , class , extends , meta = require ( game . ReplicatedStorage . Packages . LuaClass )() class \"MathStruct\" { firstValue = 0 ; lastValue = nil ; constructor = function ( this , num : number ) this . firstValue = num return this end , multiply = function ( this , by : number ): number this . lastValue = this . firstValue * by return this . lastValue end , } local mathStruct = new \"MathStruct\" ( 5 ) print ( mathStruct . multiply ( 3 )) -- 15 class \"WithAddition\" [ extends \"MathStruct\" ] { add = function ( this , amount : number ): number this . lastValue = this . firstValue + amount return this . lastValue end , } local withAddition = new \"WithAddition\" ( 7 ) print ( withAddition . multiply ( 3 )) -- 21 print ( withAddition . add ( 13 )) -- 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local MathStruct = {} MathStruct . __index = MathStruct function MathStruct . new ( num : number ) local mt = {} mt . firstValue = num mt . lastValue = nil setmetatable ( mt , MathStruct ) return mt end function MathStruct : multiply ( by : number ): number self . lastValue = self . firstValue * by return self . lastValue end local mathStruct = MathStruct . new ( 5 ) print ( mathStruct : multiply ( 3 )) -- 15 local WithAddition = {} function WithAddition : __index ( index ) return WithAddition [ index ] or MathStruct [ index ] end function WithAddition . new ( num : number ) local mt = {} mt . firstValue = num mt . lastValue = nil setmetatable ( mt , WithAddition ) return mt end function WithAddition : add ( amount : number ): number self . lastValue = self . firstValue + amount return self . lastValue end local withAddition = WithAddition . new ( 7 ) print ( withAddition : multiply ( 3 )) -- 21 print ( withAddition : add ( 13 )) -- 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MathStruct { firstValue : number lastValue : number constructor ( num : number ) { this . firstValue = num ; } multiply ( by : number ) : number { this . lastValue = this . firstValue * by ; return this . lastValue ; } } const mathStruct = new MathStruct ( 5 ); console . log ( mathStruct . multiply ( 3 )); // 15 class WithAddition extends MathStruct { constructor ( num : number ) { super ( num ); } add ( amount : number ) : number { this . lastValue = this . firstValue + amount ; return this . firstValue ; } } const withAddition = new WithAddition (); console . log ( withAddition . multiply ( 3 )); // 21 console . log ( withAddition . add ( 13 )) // 20","title":"Comparison"},{"location":"luaclass/usage/","text":"Usage Firstly, you will need to require the Classes Package. By the way, I might be taking snippets directly from the JavaScript classes reference from Mozilla. dwi About class extending If you're afraid that class extending isn't a thing here, it is: I just wont talk about it right away. Use the menu on the right to skip down to it if you'd like to! local new , class , extends , meta = require ( game . ReplicatedStorage . Packages . LuaClass )() Tip If you're using my Import package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local new , class , extends , meta = import \"@wally/luaClass\" () Defining Classes You define a class by using the built-in class function. LuaClass TS class \"Rectangle\" { constructor = function ( this , height : number , width : number ) this . height = height this . width = width return this end } local rectangle = new \"Rectangle\" ( 3 , 5 ) class Rectangle { constructor ( height : number , width : number ) { this . height = height ; this . width = width ; } } const rectangle = new Rectangle ( 3 , 5 ) Making a part with your rectangle Now let's add a new method to your Rectangle class, being able to turn it into an actually usable Part might just be what you want. class \"Rectangle\" { constructor = function ( this , height : number , width : number ) this . height = height this . width = width return this end , generate = function ( this ): Part local part = Instance . new ( \"Part\" ) part . Size = Vector3 . new ( 1 , this . height , this . width ) part . Parent = workspace return part end , } local rectangle = new \"Rectangle\" ( 3 , 5 ) rectangle . generate (). Name = \"a cool part\" Just like that now you're a professional at Classes! (just don't think about touching Java, don't do that to yourself.) Subclasses with extends You can also create children of another class, aka. forcing it into another class. LuaClass TS class \"Animal\" { constructor = function ( this , name : string ) this . name = name return this end , speak = function ( this ) print ( this . name .. \" makes a noise.\" ) end , } class \"Dog\" [ extends \"Animal\" ] { speak = function ( this ) print ( this . name .. \" barks.\" ) end , growl = function ( this ) print ( this . name .. \"growls.\" ) end , } local dog = new \"Dog\" ( \"Mitzie\" ) dog . speak () dog . growl () class Animal { constructor ( name : string ) { this . name = name ; } speak () { console . log ( this . name + \" makes a noise.\" ); } } class Dog extends Animal { constructor ( name : string ) { super ( name ); } speak () { console . log ( this . name + \" barks.\" ); } growl () { console . log ( this . name + \" growls.\" ); } } const dog = new Dog ( \"Mitzie\" ); dog . speak (); dog . growl (); Global Index A special feature that was added to this is a global index. This is mainly here because so you don't have to constantly import a class from a different module all of the time. Do note this is bad practice for idiomacy. Warning Classes will only be pushed to the global index if you require LuaClasses like this: local new , class , extends = require ( game . ReplicatedStorage . Packages . LuaClass )( true ) Or, if use my import module: local new , class , extends = import \"@wally/luaClass\" ( true ) However, they will be available in all scripts requiring LuaClass, no matter if they pass this flag or not. someClass.lua local _ , class = require ( game . ReplicatedStorage . Packages . LuaClass )( true ) class \"Circle\" { constructor = function ( this , radius : number ) this . radius = radius return this end , getArea = function ( this ) return math.pi * this . radius ^ 2 end , } script.server.lua local new = require ( game . ReplicatedStorage . Packages . LuaClass )() local circle = new \"Circle\" ( 5 ) print ( circle . getArea ()) -- 78.5398163 Good Practice - Idiomacy someClass.lua local _ , class = require ( game . ReplicatedStorage . Packages . LuaClass )() return class \"Circle\" { constructor = function ( this , radius : number ) this . radius = radius return this end , getArea = function ( this ) return math.pi * this . radius ^ 2 end , } script.server.lua local new , class = require ( game . ReplicatedStorage . Packages . LuaClass )() class [ \"Circle\" ] = require ( script . SomeClass ) local circle = new \"Circle\" ( 5 ) print ( circle . getArea ()) -- 78.5398163 Metamethods Defining metamethods with LuaClass may become important for if you want a custom way of interfacing __index and __newindex , heres an example of metamethoding with LuaClass: local new , class , extends , meta = require ( game . ReplicatedStorage . Package . LuaClass )() class \"Animal\" { constructor = function ( this , name : string ) this . name = name return this end , [ meta \"index\" ] = function ( this , index ) return this . name .. \" \" .. index .. \"s.\" end , } local animal = new \"Animal\" ( \"Mitzie\" ) print ( animal [ \"bark\" ]) -- \"Mitzie barks.\"","title":"Usage"},{"location":"luaclass/usage/#usage","text":"Firstly, you will need to require the Classes Package. By the way, I might be taking snippets directly from the JavaScript classes reference from Mozilla. dwi About class extending If you're afraid that class extending isn't a thing here, it is: I just wont talk about it right away. Use the menu on the right to skip down to it if you'd like to! local new , class , extends , meta = require ( game . ReplicatedStorage . Packages . LuaClass )() Tip If you're using my Import package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local new , class , extends , meta = import \"@wally/luaClass\" ()","title":"Usage"},{"location":"luaclass/usage/#defining-classes","text":"You define a class by using the built-in class function. LuaClass TS class \"Rectangle\" { constructor = function ( this , height : number , width : number ) this . height = height this . width = width return this end } local rectangle = new \"Rectangle\" ( 3 , 5 ) class Rectangle { constructor ( height : number , width : number ) { this . height = height ; this . width = width ; } } const rectangle = new Rectangle ( 3 , 5 )","title":"Defining Classes"},{"location":"luaclass/usage/#making-a-part-with-your-rectangle","text":"Now let's add a new method to your Rectangle class, being able to turn it into an actually usable Part might just be what you want. class \"Rectangle\" { constructor = function ( this , height : number , width : number ) this . height = height this . width = width return this end , generate = function ( this ): Part local part = Instance . new ( \"Part\" ) part . Size = Vector3 . new ( 1 , this . height , this . width ) part . Parent = workspace return part end , } local rectangle = new \"Rectangle\" ( 3 , 5 ) rectangle . generate (). Name = \"a cool part\" Just like that now you're a professional at Classes! (just don't think about touching Java, don't do that to yourself.)","title":"Making a part with your rectangle"},{"location":"luaclass/usage/#subclasses-with-extends","text":"You can also create children of another class, aka. forcing it into another class. LuaClass TS class \"Animal\" { constructor = function ( this , name : string ) this . name = name return this end , speak = function ( this ) print ( this . name .. \" makes a noise.\" ) end , } class \"Dog\" [ extends \"Animal\" ] { speak = function ( this ) print ( this . name .. \" barks.\" ) end , growl = function ( this ) print ( this . name .. \"growls.\" ) end , } local dog = new \"Dog\" ( \"Mitzie\" ) dog . speak () dog . growl () class Animal { constructor ( name : string ) { this . name = name ; } speak () { console . log ( this . name + \" makes a noise.\" ); } } class Dog extends Animal { constructor ( name : string ) { super ( name ); } speak () { console . log ( this . name + \" barks.\" ); } growl () { console . log ( this . name + \" growls.\" ); } } const dog = new Dog ( \"Mitzie\" ); dog . speak (); dog . growl ();","title":"Subclasses with extends"},{"location":"luaclass/usage/#global-index","text":"A special feature that was added to this is a global index. This is mainly here because so you don't have to constantly import a class from a different module all of the time. Do note this is bad practice for idiomacy. Warning Classes will only be pushed to the global index if you require LuaClasses like this: local new , class , extends = require ( game . ReplicatedStorage . Packages . LuaClass )( true ) Or, if use my import module: local new , class , extends = import \"@wally/luaClass\" ( true ) However, they will be available in all scripts requiring LuaClass, no matter if they pass this flag or not. someClass.lua local _ , class = require ( game . ReplicatedStorage . Packages . LuaClass )( true ) class \"Circle\" { constructor = function ( this , radius : number ) this . radius = radius return this end , getArea = function ( this ) return math.pi * this . radius ^ 2 end , } script.server.lua local new = require ( game . ReplicatedStorage . Packages . LuaClass )() local circle = new \"Circle\" ( 5 ) print ( circle . getArea ()) -- 78.5398163 Good Practice - Idiomacy someClass.lua local _ , class = require ( game . ReplicatedStorage . Packages . LuaClass )() return class \"Circle\" { constructor = function ( this , radius : number ) this . radius = radius return this end , getArea = function ( this ) return math.pi * this . radius ^ 2 end , } script.server.lua local new , class = require ( game . ReplicatedStorage . Packages . LuaClass )() class [ \"Circle\" ] = require ( script . SomeClass ) local circle = new \"Circle\" ( 5 ) print ( circle . getArea ()) -- 78.5398163","title":"Global Index"},{"location":"luaclass/usage/#metamethods","text":"Defining metamethods with LuaClass may become important for if you want a custom way of interfacing __index and __newindex , heres an example of metamethoding with LuaClass: local new , class , extends , meta = require ( game . ReplicatedStorage . Package . LuaClass )() class \"Animal\" { constructor = function ( this , name : string ) this . name = name return this end , [ meta \"index\" ] = function ( this , index ) return this . name .. \" \" .. index .. \"s.\" end , } local animal = new \"Animal\" ( \"Mitzie\" ) print ( animal [ \"bark\" ]) -- \"Mitzie barks.\"","title":"Metamethods"},{"location":"switchcase/","text":"SwitchCase SwitchCase is an implementation of switch/case from JavaScript and other popular languages (like Java). It attempts to recreate it syntactically similar. However, doing this in Roblox is not easy due to how variables are encapsulated. Installation Using Wally SwitchCase is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SwitchCase = \"alexinite/switch-case@0.1.2\" wally install New to Wally? Read more about it . Requiring SwitchCase will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Usage First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local switch , case , default = require ( game . ReplicatedStorage . Packages . SwitchCase )() Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local switch , case , default = import \"@wally/switchCase\" () Using SwitchCase functions relatively like JavaScript's Switch-Case. Here's an example of them side-by-side: Luau JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local num = 6 switch ( num ) { case ( 2 ) ( function () print ( \"number was 2!\" ) end ), case ( 5 ) ( function () print ( \"number was 5!\" ) end ), default ( function () print ( \"number was actually \" .. num ) end ) } 1 2 3 4 5 6 7 let num = 6 switch ( num ) { case 2 : console . log ( \"number was 2!\" ) case 5 : console . log ( \"number was 5!\" ) default : console . log ( \"number was actually \" + num ) }","title":"SwitchCase"},{"location":"switchcase/#switchcase","text":"SwitchCase is an implementation of switch/case from JavaScript and other popular languages (like Java). It attempts to recreate it syntactically similar. However, doing this in Roblox is not easy due to how variables are encapsulated.","title":"SwitchCase"},{"location":"switchcase/#installation","text":"","title":"Installation"},{"location":"switchcase/#using-wally","text":"SwitchCase is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SwitchCase = \"alexinite/switch-case@0.1.2\" wally install New to Wally? Read more about it . Requiring SwitchCase will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"switchcase/#usage","text":"First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local switch , case , default = require ( game . ReplicatedStorage . Packages . SwitchCase )() Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local switch , case , default = import \"@wally/switchCase\" () Using SwitchCase functions relatively like JavaScript's Switch-Case. Here's an example of them side-by-side: Luau JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local num = 6 switch ( num ) { case ( 2 ) ( function () print ( \"number was 2!\" ) end ), case ( 5 ) ( function () print ( \"number was 5!\" ) end ), default ( function () print ( \"number was actually \" .. num ) end ) } 1 2 3 4 5 6 7 let num = 6 switch ( num ) { case 2 : console . log ( \"number was 2!\" ) case 5 : console . log ( \"number was 5!\" ) default : console . log ( \"number was actually \" + num ) }","title":"Usage"}]}
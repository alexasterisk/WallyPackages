{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Collection of Wally Packages Classes v0.1.3 lua-objects Utilities v0.1.7 import v0.1.1 logger v0.1.0 tween Internal Resources v0.1.0 table-util v0.1.0 player-resolvable Hosted Packages v2.3.2 alexinite/maid This project belongs to Quenty . v0.2.0-bleeding alexinite/fusion A version of Fusion which is always up-to-date with the primary fork. This is bleeding-edge. If you're looking for the beta version, ruizukun-dev hosts that ruizukun-dev/fusion@1.0.0 . This project belongs to Elttob . Archive v0.1.2 lua-class v0.1.2 lua-array v0.1.2 switch-case","title":"Home"},{"location":"#collection-of-wally-packages","text":"","title":"Collection of Wally Packages"},{"location":"#classes","text":"","title":"Classes"},{"location":"#v013-lua-objects","text":"","title":"v0.1.3 lua-objects"},{"location":"#utilities","text":"","title":"Utilities"},{"location":"#v017-import","text":"","title":"v0.1.7 import"},{"location":"#v011-logger","text":"","title":"v0.1.1 logger"},{"location":"#v010-tween","text":"","title":"v0.1.0 tween"},{"location":"#internal-resources","text":"","title":"Internal Resources"},{"location":"#v010-table-util","text":"","title":"v0.1.0 table-util"},{"location":"#v010-player-resolvable","text":"","title":"v0.1.0 player-resolvable"},{"location":"#hosted-packages","text":"","title":"Hosted Packages"},{"location":"#v232-alexinitemaid","text":"This project belongs to Quenty .","title":"v2.3.2 alexinite/maid"},{"location":"#v020-bleeding-alexinitefusion","text":"A version of Fusion which is always up-to-date with the primary fork. This is bleeding-edge. If you're looking for the beta version, ruizukun-dev hosts that ruizukun-dev/fusion@1.0.0 . This project belongs to Elttob .","title":"v0.2.0-bleeding alexinite/fusion"},{"location":"#archive","text":"","title":"Archive"},{"location":"#v012-lua-class","text":"","title":"v0.1.2 lua-class"},{"location":"#v012-lua-array","text":"","title":"v0.1.2 lua-array"},{"location":"#v012-switch-case","text":"","title":"v0.1.2 switch-case"},{"location":"arrays/","text":"LuaArray LuaArray is a full* implementation of arrays from JavaScript . This is only missing [@@Symbol] iterators and certain prototype methods. Installation Using Wally Warning LuaArray depends on LuaClass , another project of mine. This is not just an internal requirement but also a requirement on your end as you'll need to be able to accesss the new method. LuaArray is available via Wally + Rojo workflow, if you're new to Wally or never heard of it, read more about it here ! wally.toml [package] name = \"user/repo\" description = \"is this a cool project? yes it is\" version = \"0.1.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] LuaArray = \"alexinite/lua-array@0.1.0\" After doing this, run wally install on your command line while in your project's repository. Requiring LuaArray will depend on your Rojo project format, for the following examples I will assume you have it like the following, if you've used Wally before you're probably already familiar with this format. *.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Comparison To start of, it's a good idea to show how these would behave in comparison to JavaScript arrays: LuaArray TS 1 2 3 4 5 6 7 8 9 10 11 12 13 local new = require ( game . ReplicatedStorage . Packages . LuaClass )() local array = new \"Array\" ( 5 , 12 ) -- [5, 12] local newAmount = array . push ( 7 ) -- 3 local mappedArray = array . map ( function ( num : number ) return num * 2 end ) -- [10, 24, 14] print ( mappedArray [ 2 ]) -- 24 if mappedArray . includes ( 10 ) then print ( mappedArray . indexOf ( 10 )) -- 2 end 1 2 3 4 5 6 7 8 9 const array = new Array < number > ( 5 , 12 ); // [5, 12] const newAmount = array . push ( 7 ); // 3 const mappedArray = array . map ( num => num * 2 ); // [10, 24, 14] console . log ( mappedArray [ 2 ]); // 24 if ( mappedArray . includes ( 10 )) { console . log ( mappedArray . indexOf ( 10 )) // 2 }","title":"Introduction"},{"location":"arrays/#luaarray","text":"LuaArray is a full* implementation of arrays from JavaScript . This is only missing [@@Symbol] iterators and certain prototype methods.","title":"LuaArray"},{"location":"arrays/#installation","text":"","title":"Installation"},{"location":"arrays/#using-wally","text":"Warning LuaArray depends on LuaClass , another project of mine. This is not just an internal requirement but also a requirement on your end as you'll need to be able to accesss the new method. LuaArray is available via Wally + Rojo workflow, if you're new to Wally or never heard of it, read more about it here ! wally.toml [package] name = \"user/repo\" description = \"is this a cool project? yes it is\" version = \"0.1.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] LuaArray = \"alexinite/lua-array@0.1.0\" After doing this, run wally install on your command line while in your project's repository. Requiring LuaArray will depend on your Rojo project format, for the following examples I will assume you have it like the following, if you've used Wally before you're probably already familiar with this format. *.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"arrays/#comparison","text":"To start of, it's a good idea to show how these would behave in comparison to JavaScript arrays: LuaArray TS 1 2 3 4 5 6 7 8 9 10 11 12 13 local new = require ( game . ReplicatedStorage . Packages . LuaClass )() local array = new \"Array\" ( 5 , 12 ) -- [5, 12] local newAmount = array . push ( 7 ) -- 3 local mappedArray = array . map ( function ( num : number ) return num * 2 end ) -- [10, 24, 14] print ( mappedArray [ 2 ]) -- 24 if mappedArray . includes ( 10 ) then print ( mappedArray . indexOf ( 10 )) -- 2 end 1 2 3 4 5 6 7 8 9 const array = new Array < number > ( 5 , 12 ); // [5, 12] const newAmount = array . push ( 7 ); // 3 const mappedArray = array . map ( num => num * 2 ); // [10, 24, 14] console . log ( mappedArray [ 2 ]); // 24 if ( mappedArray . includes ( 10 )) { console . log ( mappedArray . indexOf ( 10 )) // 2 }","title":"Comparison"},{"location":"arrays/usage/","text":"Usage Warning Using Arrays with LuaArray is extremely on-par with JavaScript classes . Minus some things that are different with arrays with LuaArray, I will not be going over the methods/properties of Arrays. If you would like to read about those: Please read the official JavaScript references . Importing LuaArray LuaArray has it's own module when installing it with Wally, however I do not recommend requiring it from its module . It loses a lot of sugar clarity if it's not being intertwined with the new method for classes. local new = require ( game . ReplicatedStorage . Packages . LuaClass )() local array = new \"Array\" ( 5 , 12 ) -- [5, 12] print ( array . length ) -- 2 Tip If you're using my Import package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local new = import \"@wally/luaClass\" () local array = new \"Array\" ( 5 , 12 ) -- [5, 12] print ( array . length ) -- 2 Direct Require If you would still like to require it directly, here's what that may look like for you; however this format seems to get repetitive extremely quickly which is why i bundled it with LuaClass: local LuaArray = require ( game . ReplicatedStorage . Packages . LuaArray ) local array = LuaArray ( 5 , 12 ) -- [5, 12] print ( array . length ) -- 2 Logging the Array Unlike JavaScript arrays you cannot simply do print(array) due to some inconvienences of Lua metatables; however, you can get the private table directly from the Array class like the following: local array = new \"Array\" ( 5 , 12 ) -- [5, 12] print ( array . _table ) -- {[1]: 5, [2]: 12} One-indexed Unlike JavaScript, Arrays in Lua are not zero-indexed and start at 1. This is exactly how Roblox handles tables by default, so nothing new from moving from Roblox tables. Missing Properties Array[@@unscopables] Missing Methods Array[@@iterator] () get Array[@@species] Array.entries() Array.from() Array.groupBy() Array.groupByToMap() Array.isArray() Array.keys() Array.of() Array.toLocaleString() Array.toSource() Array.values()","title":"Usage"},{"location":"arrays/usage/#usage","text":"Warning Using Arrays with LuaArray is extremely on-par with JavaScript classes . Minus some things that are different with arrays with LuaArray, I will not be going over the methods/properties of Arrays. If you would like to read about those: Please read the official JavaScript references .","title":"Usage"},{"location":"arrays/usage/#importing-luaarray","text":"LuaArray has it's own module when installing it with Wally, however I do not recommend requiring it from its module . It loses a lot of sugar clarity if it's not being intertwined with the new method for classes. local new = require ( game . ReplicatedStorage . Packages . LuaClass )() local array = new \"Array\" ( 5 , 12 ) -- [5, 12] print ( array . length ) -- 2 Tip If you're using my Import package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local new = import \"@wally/luaClass\" () local array = new \"Array\" ( 5 , 12 ) -- [5, 12] print ( array . length ) -- 2 Direct Require If you would still like to require it directly, here's what that may look like for you; however this format seems to get repetitive extremely quickly which is why i bundled it with LuaClass: local LuaArray = require ( game . ReplicatedStorage . Packages . LuaArray ) local array = LuaArray ( 5 , 12 ) -- [5, 12] print ( array . length ) -- 2","title":"Importing LuaArray"},{"location":"arrays/usage/#logging-the-array","text":"Unlike JavaScript arrays you cannot simply do print(array) due to some inconvienences of Lua metatables; however, you can get the private table directly from the Array class like the following: local array = new \"Array\" ( 5 , 12 ) -- [5, 12] print ( array . _table ) -- {[1]: 5, [2]: 12}","title":"Logging the Array"},{"location":"arrays/usage/#one-indexed","text":"Unlike JavaScript, Arrays in Lua are not zero-indexed and start at 1. This is exactly how Roblox handles tables by default, so nothing new from moving from Roblox tables.","title":"One-indexed"},{"location":"arrays/usage/#missing-properties","text":"","title":"Missing Properties"},{"location":"arrays/usage/#arrayunscopables","text":"","title":"Array[@@unscopables]"},{"location":"arrays/usage/#missing-methods","text":"","title":"Missing Methods"},{"location":"arrays/usage/#arrayiterator","text":"","title":"Array[@@iterator]()"},{"location":"arrays/usage/#get-arrayspecies","text":"","title":"get Array[@@species]"},{"location":"arrays/usage/#arrayentries","text":"","title":"Array.entries()"},{"location":"arrays/usage/#arrayfrom","text":"","title":"Array.from()"},{"location":"arrays/usage/#arraygroupby","text":"","title":"Array.groupBy()"},{"location":"arrays/usage/#arraygroupbytomap","text":"","title":"Array.groupByToMap()"},{"location":"arrays/usage/#arrayisarray","text":"","title":"Array.isArray()"},{"location":"arrays/usage/#arraykeys","text":"","title":"Array.keys()"},{"location":"arrays/usage/#arrayof","text":"","title":"Array.of()"},{"location":"arrays/usage/#arraytolocalestring","text":"","title":"Array.toLocaleString()"},{"location":"arrays/usage/#arraytosource","text":"","title":"Array.toSource()"},{"location":"arrays/usage/#arrayvalues","text":"","title":"Array.values()"},{"location":"classes/","text":"LuaClass LuaClass is an implementation of classes from JavaScript to an extent. This does not include private variables due to Lua's environment. Installation Using Wally LuaClass is available via Wally + Rojo workflow, if you're new to Wally or never heard of it, read about it here ! wally.toml [package] name = \"user/repo\" description = \"some cool project, probably\" version = \"0.1.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] LuaClass = \"alexinite/lua-class@0.1.2\" After doing this (and learning Rojo + Wally, it's worth it I promise!) run wally install on your command line while in your project's repository. Requiring LuaClass will depend on your Rojo project format, for the following examples I will assume you have it like the following, if you've used Wally before you're probably already familiar with this format. *.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Comparison You might be wondering just how much this compares in looks to JavaScript classes or even just regular Roblox metatables, here's your answer: LuaClass Luau Metatables TS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local new , class , extends , meta = require ( game . ReplicatedStorage . Packages . LuaClass )() class \"MathStruct\" { firstValue = 0 ; lastValue = nil ; constructor = function ( this , num : number ) this . firstValue = num return this end , multiply = function ( this , by : number ): number this . lastValue = this . firstValue * by return this . lastValue end , } local mathStruct = new \"MathStruct\" ( 5 ) print ( mathStruct . multiply ( 3 )) -- 15 class \"WithAddition\" [ extends \"MathStruct\" ] { add = function ( this , amount : number ): number this . lastValue = this . firstValue + amount return this . lastValue end , } local withAddition = new \"WithAddition\" ( 7 ) print ( withAddition . multiply ( 3 )) -- 21 print ( withAddition . add ( 13 )) -- 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local MathStruct = {} MathStruct . __index = MathStruct function MathStruct . new ( num : number ) local mt = {} mt . firstValue = num mt . lastValue = nil setmetatable ( mt , MathStruct ) return mt end function MathStruct : multiply ( by : number ): number self . lastValue = self . firstValue * by return self . lastValue end local mathStruct = MathStruct . new ( 5 ) print ( mathStruct : multiply ( 3 )) -- 15 local WithAddition = {} function WithAddition : __index ( index ) return WithAddition [ index ] or MathStruct [ index ] end function WithAddition . new ( num : number ) local mt = {} mt . firstValue = num mt . lastValue = nil setmetatable ( mt , WithAddition ) return mt end function WithAddition : add ( amount : number ): number self . lastValue = self . firstValue + amount return self . lastValue end local withAddition = WithAddition . new ( 7 ) print ( withAddition : multiply ( 3 )) -- 21 print ( withAddition : add ( 13 )) -- 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MathStruct { firstValue : number lastValue : number constructor ( num : number ) { this . firstValue = num ; } multiply ( by : number ) : number { this . lastValue = this . firstValue * by ; return this . lastValue ; } } const mathStruct = new MathStruct ( 5 ); console . log ( mathStruct . multiply ( 3 )); // 15 class WithAddition extends MathStruct { constructor ( num : number ) { super ( num ); } add ( amount : number ) : number { this . lastValue = this . firstValue + amount ; return this . firstValue ; } } const withAddition = new WithAddition (); console . log ( withAddition . multiply ( 3 )); // 21 console . log ( withAddition . add ( 13 )) // 20","title":"Introduction"},{"location":"classes/#luaclass","text":"LuaClass is an implementation of classes from JavaScript to an extent. This does not include private variables due to Lua's environment.","title":"LuaClass"},{"location":"classes/#installation","text":"","title":"Installation"},{"location":"classes/#using-wally","text":"LuaClass is available via Wally + Rojo workflow, if you're new to Wally or never heard of it, read about it here ! wally.toml [package] name = \"user/repo\" description = \"some cool project, probably\" version = \"0.1.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] LuaClass = \"alexinite/lua-class@0.1.2\" After doing this (and learning Rojo + Wally, it's worth it I promise!) run wally install on your command line while in your project's repository. Requiring LuaClass will depend on your Rojo project format, for the following examples I will assume you have it like the following, if you've used Wally before you're probably already familiar with this format. *.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"classes/#comparison","text":"You might be wondering just how much this compares in looks to JavaScript classes or even just regular Roblox metatables, here's your answer: LuaClass Luau Metatables TS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local new , class , extends , meta = require ( game . ReplicatedStorage . Packages . LuaClass )() class \"MathStruct\" { firstValue = 0 ; lastValue = nil ; constructor = function ( this , num : number ) this . firstValue = num return this end , multiply = function ( this , by : number ): number this . lastValue = this . firstValue * by return this . lastValue end , } local mathStruct = new \"MathStruct\" ( 5 ) print ( mathStruct . multiply ( 3 )) -- 15 class \"WithAddition\" [ extends \"MathStruct\" ] { add = function ( this , amount : number ): number this . lastValue = this . firstValue + amount return this . lastValue end , } local withAddition = new \"WithAddition\" ( 7 ) print ( withAddition . multiply ( 3 )) -- 21 print ( withAddition . add ( 13 )) -- 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local MathStruct = {} MathStruct . __index = MathStruct function MathStruct . new ( num : number ) local mt = {} mt . firstValue = num mt . lastValue = nil setmetatable ( mt , MathStruct ) return mt end function MathStruct : multiply ( by : number ): number self . lastValue = self . firstValue * by return self . lastValue end local mathStruct = MathStruct . new ( 5 ) print ( mathStruct : multiply ( 3 )) -- 15 local WithAddition = {} function WithAddition : __index ( index ) return WithAddition [ index ] or MathStruct [ index ] end function WithAddition . new ( num : number ) local mt = {} mt . firstValue = num mt . lastValue = nil setmetatable ( mt , WithAddition ) return mt end function WithAddition : add ( amount : number ): number self . lastValue = self . firstValue + amount return self . lastValue end local withAddition = WithAddition . new ( 7 ) print ( withAddition : multiply ( 3 )) -- 21 print ( withAddition : add ( 13 )) -- 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MathStruct { firstValue : number lastValue : number constructor ( num : number ) { this . firstValue = num ; } multiply ( by : number ) : number { this . lastValue = this . firstValue * by ; return this . lastValue ; } } const mathStruct = new MathStruct ( 5 ); console . log ( mathStruct . multiply ( 3 )); // 15 class WithAddition extends MathStruct { constructor ( num : number ) { super ( num ); } add ( amount : number ) : number { this . lastValue = this . firstValue + amount ; return this . firstValue ; } } const withAddition = new WithAddition (); console . log ( withAddition . multiply ( 3 )); // 21 console . log ( withAddition . add ( 13 )) // 20","title":"Comparison"},{"location":"classes/usage/","text":"Usage Firstly, you will need to require the LuaClass Package. By the way, I might be taking snippets directly from the JavaScript classes reference from Mozilla. dwi About class extending If you're afraid that class extending isn't a thing here, it is: I just wont talk about it right away. Use the menu on the right to skip down to it if you'd like to! local new , class , extends , meta = require ( game . ReplicatedStorage . Packages . LuaClass )() Tip If you're using my Import package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local new , class , extends , meta = import \"@wally/luaClass\" () Defining Classes You define a class by using the built-in class function. LuaClass TS class \"Rectangle\" { constructor = function ( this , height : number , width : number ) this . height = height this . width = width return this end } local rectangle = new \"Rectangle\" ( 3 , 5 ) class Rectangle { constructor ( height : number , width : number ) { this . height = height ; this . width = width ; } } const rectangle = new Rectangle ( 3 , 5 ) Making a part with your rectangle Now let's add a new method to your Rectangle class, being able to turn it into an actually usable Part might just be what you want. class \"Rectangle\" { constructor = function ( this , height : number , width : number ) this . height = height this . width = width return this end , generate = function ( this ): Part local part = Instance . new ( \"Part\" ) part . Size = Vector3 . new ( 1 , this . height , this . width ) part . Parent = workspace return part end , } local rectangle = new \"Rectangle\" ( 3 , 5 ) rectangle . generate (). Name = \"a cool part\" Just like that now you're a professional at using classes! (just don't think about touching Java, don't do that to yourself.) Subclasses with extends You can also create children of another class, aka. forcing it into another class. LuaClass TS class \"Animal\" { constructor = function ( this , name : string ) this . name = name return this end , speak = function ( this ) print ( this . name .. \" makes a noise.\" ) end , } class \"Dog\" [ extends \"Animal\" ] { speak = function ( this ) print ( this . name .. \" barks.\" ) end , growl = function ( this ) print ( this . name .. \"growls.\" ) end , } local dog = new \"Dog\" ( \"Mitzie\" ) dog . speak () dog . growl () class Animal { constructor ( name : string ) { this . name = name ; } speak () { console . log ( this . name + \" makes a noise.\" ); } } class Dog extends Animal { constructor ( name : string ) { super ( name ); } speak () { console . log ( this . name + \" barks.\" ); } growl () { console . log ( this . name + \" growls.\" ); } } const dog = new Dog ( \"Mitzie\" ); dog . speak (); dog . growl (); Global Index A special feature that was added to this is a global index. This is mainly here because so you don't have to constantly import a class from a different module all of the time. Do note this is bad practice for idiomacy. Warning Classes will only be pushed to the global index if you require LuaClass like this: local new , class , extends = require ( game . ReplicatedStorage . Packages . LuaClass )( true ) Or, if use my import module: local new , class , extends = import \"@wally/luaClass\" ( true ) However, they will be available in all scripts requiring LuaClass, no matter if they pass this flag or not. someClass.lua local _ , class = require ( game . ReplicatedStorage . Packages . LuaClass )( true ) class \"Circle\" { constructor = function ( this , radius : number ) this . radius = radius return this end , getArea = function ( this ) return math.pi * this . radius ^ 2 end , } script.server.lua local new = require ( game . ReplicatedStorage . Packages . LuaClass )() local circle = new \"Circle\" ( 5 ) print ( circle . getArea ()) -- 78.5398163 Good Practice - Idiomacy someClass.lua local _ , class = require ( game . ReplicatedStorage . Packages . LuaClass )() return class \"Circle\" { constructor = function ( this , radius : number ) this . radius = radius return this end , getArea = function ( this ) return math.pi * this . radius ^ 2 end , } script.server.lua local new , class = require ( game . ReplicatedStorage . Packages . LuaClass )() class [ \"Circle\" ] = require ( script . SomeClass ) local circle = new \"Circle\" ( 5 ) print ( circle . getArea ()) -- 78.5398163 Metamethods Defining metamethods with LuaClass may become important for if you want a custom way of interfacing __index and __newindex , heres an example of metamethoding with LuaClass: local new , class , extends , meta = require ( game . ReplicatedStorage . Package . LuaClass )() class \"Animal\" { constructor = function ( this , name : string ) this . name = name return this end , [ meta \"index\" ] = function ( this , index ) return this . name .. \" \" .. index .. \"s.\" end , } local animal = new \"Animal\" ( \"Mitzie\" ) print ( animal [ \"bark\" ]) -- \"Mitzie barks.\"","title":"Usage"},{"location":"classes/usage/#usage","text":"Firstly, you will need to require the LuaClass Package. By the way, I might be taking snippets directly from the JavaScript classes reference from Mozilla. dwi About class extending If you're afraid that class extending isn't a thing here, it is: I just wont talk about it right away. Use the menu on the right to skip down to it if you'd like to! local new , class , extends , meta = require ( game . ReplicatedStorage . Packages . LuaClass )() Tip If you're using my Import package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local new , class , extends , meta = import \"@wally/luaClass\" ()","title":"Usage"},{"location":"classes/usage/#defining-classes","text":"You define a class by using the built-in class function. LuaClass TS class \"Rectangle\" { constructor = function ( this , height : number , width : number ) this . height = height this . width = width return this end } local rectangle = new \"Rectangle\" ( 3 , 5 ) class Rectangle { constructor ( height : number , width : number ) { this . height = height ; this . width = width ; } } const rectangle = new Rectangle ( 3 , 5 )","title":"Defining Classes"},{"location":"classes/usage/#making-a-part-with-your-rectangle","text":"Now let's add a new method to your Rectangle class, being able to turn it into an actually usable Part might just be what you want. class \"Rectangle\" { constructor = function ( this , height : number , width : number ) this . height = height this . width = width return this end , generate = function ( this ): Part local part = Instance . new ( \"Part\" ) part . Size = Vector3 . new ( 1 , this . height , this . width ) part . Parent = workspace return part end , } local rectangle = new \"Rectangle\" ( 3 , 5 ) rectangle . generate (). Name = \"a cool part\" Just like that now you're a professional at using classes! (just don't think about touching Java, don't do that to yourself.)","title":"Making a part with your rectangle"},{"location":"classes/usage/#subclasses-with-extends","text":"You can also create children of another class, aka. forcing it into another class. LuaClass TS class \"Animal\" { constructor = function ( this , name : string ) this . name = name return this end , speak = function ( this ) print ( this . name .. \" makes a noise.\" ) end , } class \"Dog\" [ extends \"Animal\" ] { speak = function ( this ) print ( this . name .. \" barks.\" ) end , growl = function ( this ) print ( this . name .. \"growls.\" ) end , } local dog = new \"Dog\" ( \"Mitzie\" ) dog . speak () dog . growl () class Animal { constructor ( name : string ) { this . name = name ; } speak () { console . log ( this . name + \" makes a noise.\" ); } } class Dog extends Animal { constructor ( name : string ) { super ( name ); } speak () { console . log ( this . name + \" barks.\" ); } growl () { console . log ( this . name + \" growls.\" ); } } const dog = new Dog ( \"Mitzie\" ); dog . speak (); dog . growl ();","title":"Subclasses with extends"},{"location":"classes/usage/#global-index","text":"A special feature that was added to this is a global index. This is mainly here because so you don't have to constantly import a class from a different module all of the time. Do note this is bad practice for idiomacy. Warning Classes will only be pushed to the global index if you require LuaClass like this: local new , class , extends = require ( game . ReplicatedStorage . Packages . LuaClass )( true ) Or, if use my import module: local new , class , extends = import \"@wally/luaClass\" ( true ) However, they will be available in all scripts requiring LuaClass, no matter if they pass this flag or not. someClass.lua local _ , class = require ( game . ReplicatedStorage . Packages . LuaClass )( true ) class \"Circle\" { constructor = function ( this , radius : number ) this . radius = radius return this end , getArea = function ( this ) return math.pi * this . radius ^ 2 end , } script.server.lua local new = require ( game . ReplicatedStorage . Packages . LuaClass )() local circle = new \"Circle\" ( 5 ) print ( circle . getArea ()) -- 78.5398163 Good Practice - Idiomacy someClass.lua local _ , class = require ( game . ReplicatedStorage . Packages . LuaClass )() return class \"Circle\" { constructor = function ( this , radius : number ) this . radius = radius return this end , getArea = function ( this ) return math.pi * this . radius ^ 2 end , } script.server.lua local new , class = require ( game . ReplicatedStorage . Packages . LuaClass )() class [ \"Circle\" ] = require ( script . SomeClass ) local circle = new \"Circle\" ( 5 ) print ( circle . getArea ()) -- 78.5398163","title":"Global Index"},{"location":"classes/usage/#metamethods","text":"Defining metamethods with LuaClass may become important for if you want a custom way of interfacing __index and __newindex , heres an example of metamethoding with LuaClass: local new , class , extends , meta = require ( game . ReplicatedStorage . Package . LuaClass )() class \"Animal\" { constructor = function ( this , name : string ) this . name = name return this end , [ meta \"index\" ] = function ( this , index ) return this . name .. \" \" .. index .. \"s.\" end , } local animal = new \"Animal\" ( \"Mitzie\" ) print ( animal [ \"bark\" ]) -- \"Mitzie barks.\"","title":"Metamethods"},{"location":"import/","text":"Introduction Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . For starters, you'll need to know how to use Roblox Studio... ~and Luau~... Anyways, Import is a Require module like TypeScript's import . Sugar No Sugar local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"shared/someClass\" local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import ( \"shared/someClass\" ) Sugar Syntax Due to Lua's weird sugar syntax rules when it comes to encapsulation: You can create this weird syntax which drives some people insane but I personally think it looks cool. This is inspired off of Elttob's Fusion module .","title":"Introduction"},{"location":"import/#introduction","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . For starters, you'll need to know how to use Roblox Studio... ~and Luau~... Anyways, Import is a Require module like TypeScript's import . Sugar No Sugar local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"shared/someClass\" local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import ( \"shared/someClass\" )","title":"Introduction"},{"location":"import/#sugar-syntax","text":"Due to Lua's weird sugar syntax rules when it comes to encapsulation: You can create this weird syntax which drives some people insane but I personally think it looks cool. This is inspired off of Elttob's Fusion module .","title":"Sugar Syntax"},{"location":"import/installation/","text":"Installation Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Installing Import is as simple as simple as I could've ever made it. It's necessary to install it via your prefered method. Using Rojo If you use Rojo, this is relatively easy by setting up your Rojo workflow like the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Import = \"alexinite/import@0.1.7\" default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" }, \"DevPackages\" : { \"$path\" : \"DevPackages\" } }, \"ServerScriptService\" : { \"$path\" : \"src/server\" , \"Packages\" : { \"$path\" : \"ServerPackages\" } } ... } } After that, you just have to run wally install in your project's directory. Using GitHub For those that use GitHub, you will to download the .zip file on the repository and copy the entire folder of src/Import into the Packages folder in ReplicatedStorage.","title":"Installation"},{"location":"import/installation/#installation","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Installing Import is as simple as simple as I could've ever made it. It's necessary to install it via your prefered method.","title":"Installation"},{"location":"import/installation/#using-rojo","text":"If you use Rojo, this is relatively easy by setting up your Rojo workflow like the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Import = \"alexinite/import@0.1.7\" default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" }, \"DevPackages\" : { \"$path\" : \"DevPackages\" } }, \"ServerScriptService\" : { \"$path\" : \"src/server\" , \"Packages\" : { \"$path\" : \"ServerPackages\" } } ... } } After that, you just have to run wally install in your project's directory.","title":"Using Rojo"},{"location":"import/installation/#using-github","text":"For those that use GitHub, you will to download the .zip file on the repository and copy the entire folder of src/Import into the Packages folder in ReplicatedStorage.","title":"Using GitHub"},{"location":"import/usage/","text":"Usage Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Reference Points Referencing using import is in close parity with TypeScript's import from and formatted around Rojo's traditional workflow. It's also worth to note that the first letter of what you're requiring is interchangeable with uppercase and lowercase. Wally Packages When Importing packages from Wally, you will need your Rojo workflow to look like the following: default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" }, \"DevPackages\" : { \"$path\" : \"DevPackages\" } }, \"ServerScriptService\" : { \"$path\" : \"src/server\" , \"Packages\" : { \"$path\" : \"ServerPackages\" } } ... } } Then, after installing with wally install , you can require a Wally package like this: Example 1 2 3 local import = require ( game . ReplicatedStorage . Packages . Import ) local Maid = import \"@wally/maid\" Tip If you're importing a dev-package or server-package, it can be done like this: local devPackage = import \"@wally-dev/someDevPackage\" local serverPackage = import \"@wally-server/someServerPackage\" ReplicatedStorage Example local SomeClass = import \"shared/classModule\" StarterPlayerScripts Example *.client.lua local SomeClass = import \"client/classModule\" Client-Only Using client/ can only be done in a client-sided context. Attempting to access it from a server-sided context will result in an error. ServerScriptService Example *.server.lua local SomeClass = import \"server/classModule\" Server-Only Using server/ can only be done in a server-sided context. Attempting to access it from a client-sided context will result in an error. Dot References One thing to tackle with this project was allowing TypeScript's ./ and ../ to be available from all contexts. Mostly for use with submodules. Example 1 2 3 4 local import = require ( game . ReplicatedStorage . Packages . Import ) ( script ) local SomeSubclass = import \"./subclass\" local ClassInSameDir = import \"../otherClass\" Don't forget to run (script) Forgetting (script) when requiring import in times where a dot reference is used will result in an error.","title":"Usage"},{"location":"import/usage/#usage","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to .","title":"Usage"},{"location":"import/usage/#reference-points","text":"Referencing using import is in close parity with TypeScript's import from and formatted around Rojo's traditional workflow. It's also worth to note that the first letter of what you're requiring is interchangeable with uppercase and lowercase.","title":"Reference Points"},{"location":"import/usage/#wally-packages","text":"When Importing packages from Wally, you will need your Rojo workflow to look like the following: default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" }, \"DevPackages\" : { \"$path\" : \"DevPackages\" } }, \"ServerScriptService\" : { \"$path\" : \"src/server\" , \"Packages\" : { \"$path\" : \"ServerPackages\" } } ... } } Then, after installing with wally install , you can require a Wally package like this: Example 1 2 3 local import = require ( game . ReplicatedStorage . Packages . Import ) local Maid = import \"@wally/maid\" Tip If you're importing a dev-package or server-package, it can be done like this: local devPackage = import \"@wally-dev/someDevPackage\" local serverPackage = import \"@wally-server/someServerPackage\"","title":"Wally Packages"},{"location":"import/usage/#replicatedstorage","text":"Example local SomeClass = import \"shared/classModule\"","title":"ReplicatedStorage"},{"location":"import/usage/#starterplayerscripts","text":"Example *.client.lua local SomeClass = import \"client/classModule\" Client-Only Using client/ can only be done in a client-sided context. Attempting to access it from a server-sided context will result in an error.","title":"StarterPlayerScripts"},{"location":"import/usage/#serverscriptservice","text":"Example *.server.lua local SomeClass = import \"server/classModule\" Server-Only Using server/ can only be done in a server-sided context. Attempting to access it from a client-sided context will result in an error.","title":"ServerScriptService"},{"location":"import/usage/#dot-references","text":"One thing to tackle with this project was allowing TypeScript's ./ and ../ to be available from all contexts. Mostly for use with submodules. Example 1 2 3 4 local import = require ( game . ReplicatedStorage . Packages . Import ) ( script ) local SomeSubclass = import \"./subclass\" local ClassInSameDir = import \"../otherClass\" Don't forget to run (script) Forgetting (script) when requiring import in times where a dot reference is used will result in an error.","title":"Dot References"},{"location":"logger/","text":"Logger Logger is typically an internal package I use with my other packages; however, I find it really useful to use. Installation Using Wally Logger is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/logger@0.1.1\" wally install New to Wally? Read more about it . Requiring Logger will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Usage First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. When requiring the Logger, the first function will provide the name of the file you're initiating the Logger with. This is useful so you know which file is logging what. local logger = require ( game . ReplicatedStorage . Packages . Logger ) \"fileName\" Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local logger = import \"@wally/logger\" \"fileName\" Trying to keep the Logger relatively similiar to Roblox's built-in, it functions almost identical. There is a key difference however: I introduced Python-like string formatting . Luau Python 1 2 3 4 5 local name = \"Johnny\" logger . logf ( \"Hello, {name}!\" , { name }) logger . errf ( \"There was an error! Due to {name}!\" , { name }) 1 2 name = \"Johnny\" print ( f 'Hello, { name } !' ) Obviously, doing the variable encapsulation in Lua would only be possible if the variable was not localized. This will be touched on more in the Usage. Luau Non-Localized 1 2 3 4 local logger = require ( \"path/to/logger\" ) \"fileName\" name = \"Johnny\" logger . env . logf ( \"Hello, {name}!\" )","title":"Introduction"},{"location":"logger/#logger","text":"Logger is typically an internal package I use with my other packages; however, I find it really useful to use.","title":"Logger"},{"location":"logger/#installation","text":"","title":"Installation"},{"location":"logger/#using-wally","text":"Logger is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/logger@0.1.1\" wally install New to Wally? Read more about it . Requiring Logger will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"logger/#usage","text":"First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. When requiring the Logger, the first function will provide the name of the file you're initiating the Logger with. This is useful so you know which file is logging what. local logger = require ( game . ReplicatedStorage . Packages . Logger ) \"fileName\" Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local logger = import \"@wally/logger\" \"fileName\" Trying to keep the Logger relatively similiar to Roblox's built-in, it functions almost identical. There is a key difference however: I introduced Python-like string formatting . Luau Python 1 2 3 4 5 local name = \"Johnny\" logger . logf ( \"Hello, {name}!\" , { name }) logger . errf ( \"There was an error! Due to {name}!\" , { name }) 1 2 name = \"Johnny\" print ( f 'Hello, { name } !' ) Obviously, doing the variable encapsulation in Lua would only be possible if the variable was not localized. This will be touched on more in the Usage. Luau Non-Localized 1 2 3 4 local logger = require ( \"path/to/logger\" ) \"fileName\" name = \"Johnny\" logger . env . logf ( \"Hello, {name}!\" )","title":"Usage"},{"location":"logger/usage/","text":"Usage To get started, you will need to require the Logger package. Usage of GETFENV() Using logger.env. will use getfenv() ! If you're afraid of breaking Luau optimizations, feel free to just use the default logger! This also applies to using logger.format(\"string\", true) . local logger = require ( game . ReplicatedStorage . Packages . Logger ) \"fileName\" Tip If you're using my Import package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local logger = import \"@wally/logger\" \"fileName\" Using the formatter logger.format(string, any[]|boolean, number?) If you're just using the Logger for it's Python-like string formatting , you can simply use logger.format() Luau Python local name = \"Johnny\" logger . format ( \"Hello, {name}!\" , { name }) --- \"Hello, Johnny!\" name = \"Johnny\" print ( f 'Hello, { name } !' ) Non-Localized Variables Luau Optimizations By using logger.format(string, true) it will use getfenv() which currently breaks Luau optimizations! To make formatting almost identical to Python, I added a method which will use getfenv() to find your non-local variables. name = \"Johnny\" logger . format ( \"Hello, {name}!\" , true ) -- \"Hello, Johnny!\" These variables have to not be defined by local or else the formatter will not be able to find them. local name = \"Johnny\" logger . format ( \"Hello, {name}!\" , true ) -- errors Printing a message logger.log(string, ...) This simply prints a message, accepting varadic arguments to print as extra data. logger . log ( \"Hello from the Logger!\" ) logger . log ( \"Hello from varargs!\" , \"Hi!\" , \"How are you?\" ) logger.logf(string, any[], ...) This prints a message but uses the built-in formatter. This will match Python formatting. Just like logger.log this will accept varadic arguments to print as extra data. logger . logf ( \"Hello from {name}!\" , { \"Alex\" }) -- \"Hello from Alex!\" logger . logf ( \"Hello from {name} and {me}!\" , { \"varargs\" , \"Alex\" }, \"other data\" ) -- \"Hello from varargs and Alex!\", \"other data\" However, I find this formatting pretty ugly and instead just a general replacement of the ugly string.format built-in function. logger.env.logf(string, ...) Luau Optimizations By using logger.env.logf(string, ...) it will use getfenv() which currently breaks Luau optimizations! To make logger almost identical to Python, this will use getfenv() to find the non-local variable you referenced. This also accepts varadic arguments like every other log method. name = \"Johnny\" logger . env . logf ( \"Hello, {name}!\" ) -- \"Hello, Johnny!\" logger . env . logf ( \"Hello, {name}!\" , \"other data\" ) -- \"Hello, Johnny!\" \"other data\" local location = \"Workspace\" -- has to be NOT local logger . env . logf ( \"Go to {location} please!\" ) -- errors Printing a warning logger.warn(string, ...) This simply warns with a message, accepting varadic arguments to print as extra data. logger . warn ( \"This is a warning!\" ) logger . warn ( \"This is warning with extra data!\" , \"More!\" , \"So many warnings!\" ) logger.warnf(string, any[], ...) This warns a message but uses the built-in formatter. This will match Python formatting. Just like logger.log this will accept varadic arguments to print as extra data. logger . warnf ( \"Warning from {name}!\" , { \"Alex\" }) -- \"Warning from Alex!\" logger . warnf ( \"Warning from {name} and {me}!\" , { \"cause\" , \"Alex\" }, \"other data\" ) -- \"Warning from cause and Alex!\", \"other data\" logger.env.warnf(string, ...) Luau Optimizations By using logger.env.warnf(string, ...) it will use getfenv() which currently breaks Luau optimizations! To make logger almost identical to Python, this will use getfenv() to find the non-local variable you referenced. This also accepts varadic arguments like every other warn method. reason = \"it broke\" logger . env . warnf ( \"Warning! {reason}!\" ) -- \"Warning! it broke!\" logger . env . warnf ( \"Warning! {reason}!\" , \"other data\" ) -- \"Warning! it broke!\" \"other data\" local location = \"Workspace\" -- has to be NOT local logger . env . warnf ( \"It was caused in {location}!\" ) -- errors Throwing an error logger.err(string, number|any, ...) This simply will throw an error, accepting varadic arguments to print as extra data. If the first varadic argument is typeof number , it will be used instead as the error logging level. logger . err ( \"Oh no!\" ) logger . err ( \"Oh no!\" , \"This occurred\" ) -- \"This occurred\" \"Oh no!\" logger . err ( \"Oh no!\" , 3 , \"This occurred\" ) -- \"This occurred\" \"Oh no!\" logger.errf(string, any[], number|any, ...) This will throw an error but will use the built-in formatter. This will match Python formatting. Just like logger.err this will accept varadic arguments to print as extra data and using the first varadic argument, if it is a number, as the error logging level. local cause = \"bad B.O.\" logger . errf ( \"Oh no! {cause} broke the game!\" , { cause }) -- \"Oh no! bad B.O. broke the game!\" logger.env.errf(string, number|any, ...) Luau Optimizations By using logger.env.errf(string, number|any, ...) it will use getfenv() which currently breaks Luau optimizations! To make logger almost identical to Python, this will use getfenv() to find the non-local variable you referenced. This also accepts varadic arguments and will use the first one as the error logging level if it as a number, just like every other err method. cause = \"bad B.O.\" logger . env . errf ( \"Oh no! {cause} broke the game!\" ) -- \"Oh no! bad B.O. broke the game!\" local description = \"He really smelled\" -- has to be NOT local logger . env . errf ( \"Why did this happen? {description}\" ) --- errors","title":"Usage"},{"location":"logger/usage/#usage","text":"To get started, you will need to require the Logger package. Usage of GETFENV() Using logger.env. will use getfenv() ! If you're afraid of breaking Luau optimizations, feel free to just use the default logger! This also applies to using logger.format(\"string\", true) . local logger = require ( game . ReplicatedStorage . Packages . Logger ) \"fileName\" Tip If you're using my Import package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local logger = import \"@wally/logger\" \"fileName\"","title":"Usage"},{"location":"logger/usage/#using-the-formatter","text":"","title":"Using the formatter"},{"location":"logger/usage/#loggerformatstring-anyboolean-number","text":"If you're just using the Logger for it's Python-like string formatting , you can simply use logger.format() Luau Python local name = \"Johnny\" logger . format ( \"Hello, {name}!\" , { name }) --- \"Hello, Johnny!\" name = \"Johnny\" print ( f 'Hello, { name } !' )","title":"logger.format(string, any[]|boolean, number?)"},{"location":"logger/usage/#non-localized-variables","text":"Luau Optimizations By using logger.format(string, true) it will use getfenv() which currently breaks Luau optimizations! To make formatting almost identical to Python, I added a method which will use getfenv() to find your non-local variables. name = \"Johnny\" logger . format ( \"Hello, {name}!\" , true ) -- \"Hello, Johnny!\" These variables have to not be defined by local or else the formatter will not be able to find them. local name = \"Johnny\" logger . format ( \"Hello, {name}!\" , true ) -- errors","title":"Non-Localized Variables"},{"location":"logger/usage/#printing-a-message","text":"","title":"Printing a message"},{"location":"logger/usage/#loggerlogstring","text":"This simply prints a message, accepting varadic arguments to print as extra data. logger . log ( \"Hello from the Logger!\" ) logger . log ( \"Hello from varargs!\" , \"Hi!\" , \"How are you?\" )","title":"logger.log(string, ...)"},{"location":"logger/usage/#loggerlogfstring-any","text":"This prints a message but uses the built-in formatter. This will match Python formatting. Just like logger.log this will accept varadic arguments to print as extra data. logger . logf ( \"Hello from {name}!\" , { \"Alex\" }) -- \"Hello from Alex!\" logger . logf ( \"Hello from {name} and {me}!\" , { \"varargs\" , \"Alex\" }, \"other data\" ) -- \"Hello from varargs and Alex!\", \"other data\" However, I find this formatting pretty ugly and instead just a general replacement of the ugly string.format built-in function.","title":"logger.logf(string, any[], ...)"},{"location":"logger/usage/#loggerenvlogfstring","text":"Luau Optimizations By using logger.env.logf(string, ...) it will use getfenv() which currently breaks Luau optimizations! To make logger almost identical to Python, this will use getfenv() to find the non-local variable you referenced. This also accepts varadic arguments like every other log method. name = \"Johnny\" logger . env . logf ( \"Hello, {name}!\" ) -- \"Hello, Johnny!\" logger . env . logf ( \"Hello, {name}!\" , \"other data\" ) -- \"Hello, Johnny!\" \"other data\" local location = \"Workspace\" -- has to be NOT local logger . env . logf ( \"Go to {location} please!\" ) -- errors","title":"logger.env.logf(string, ...)"},{"location":"logger/usage/#printing-a-warning","text":"","title":"Printing a warning"},{"location":"logger/usage/#loggerwarnstring","text":"This simply warns with a message, accepting varadic arguments to print as extra data. logger . warn ( \"This is a warning!\" ) logger . warn ( \"This is warning with extra data!\" , \"More!\" , \"So many warnings!\" )","title":"logger.warn(string, ...)"},{"location":"logger/usage/#loggerwarnfstring-any","text":"This warns a message but uses the built-in formatter. This will match Python formatting. Just like logger.log this will accept varadic arguments to print as extra data. logger . warnf ( \"Warning from {name}!\" , { \"Alex\" }) -- \"Warning from Alex!\" logger . warnf ( \"Warning from {name} and {me}!\" , { \"cause\" , \"Alex\" }, \"other data\" ) -- \"Warning from cause and Alex!\", \"other data\"","title":"logger.warnf(string, any[], ...)"},{"location":"logger/usage/#loggerenvwarnfstring","text":"Luau Optimizations By using logger.env.warnf(string, ...) it will use getfenv() which currently breaks Luau optimizations! To make logger almost identical to Python, this will use getfenv() to find the non-local variable you referenced. This also accepts varadic arguments like every other warn method. reason = \"it broke\" logger . env . warnf ( \"Warning! {reason}!\" ) -- \"Warning! it broke!\" logger . env . warnf ( \"Warning! {reason}!\" , \"other data\" ) -- \"Warning! it broke!\" \"other data\" local location = \"Workspace\" -- has to be NOT local logger . env . warnf ( \"It was caused in {location}!\" ) -- errors","title":"logger.env.warnf(string, ...)"},{"location":"logger/usage/#throwing-an-error","text":"","title":"Throwing an error"},{"location":"logger/usage/#loggererrstring-numberany","text":"This simply will throw an error, accepting varadic arguments to print as extra data. If the first varadic argument is typeof number , it will be used instead as the error logging level. logger . err ( \"Oh no!\" ) logger . err ( \"Oh no!\" , \"This occurred\" ) -- \"This occurred\" \"Oh no!\" logger . err ( \"Oh no!\" , 3 , \"This occurred\" ) -- \"This occurred\" \"Oh no!\"","title":"logger.err(string, number|any, ...)"},{"location":"logger/usage/#loggererrfstring-any-numberany","text":"This will throw an error but will use the built-in formatter. This will match Python formatting. Just like logger.err this will accept varadic arguments to print as extra data and using the first varadic argument, if it is a number, as the error logging level. local cause = \"bad B.O.\" logger . errf ( \"Oh no! {cause} broke the game!\" , { cause }) -- \"Oh no! bad B.O. broke the game!\"","title":"logger.errf(string, any[], number|any, ...)"},{"location":"logger/usage/#loggerenverrfstring-numberany","text":"Luau Optimizations By using logger.env.errf(string, number|any, ...) it will use getfenv() which currently breaks Luau optimizations! To make logger almost identical to Python, this will use getfenv() to find the non-local variable you referenced. This also accepts varadic arguments and will use the first one as the error logging level if it as a number, just like every other err method. cause = \"bad B.O.\" logger . env . errf ( \"Oh no! {cause} broke the game!\" ) -- \"Oh no! bad B.O. broke the game!\" local description = \"He really smelled\" -- has to be NOT local logger . env . errf ( \"Why did this happen? {description}\" ) --- errors","title":"logger.env.errf(string, number|any, ...)"},{"location":"objects/","text":"LuaObjects (arrays-maps-sets) LuaObjects is an extended version of LuaArray , implementing almost every feature from Arrays, Maps, and Sets from JavaScript. Installation Using Wally LuaObjects is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/arrays-maps-sets@0.1.3\" wally install New to Wally? Read more about it . Requiring LuaObjects will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Introduction"},{"location":"objects/#luaobjects-arrays-maps-sets","text":"LuaObjects is an extended version of LuaArray , implementing almost every feature from Arrays, Maps, and Sets from JavaScript.","title":"LuaObjects (arrays-maps-sets)"},{"location":"objects/#installation","text":"","title":"Installation"},{"location":"objects/#using-wally","text":"LuaObjects is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/arrays-maps-sets@0.1.3\" wally install New to Wally? Read more about it . Requiring LuaObjects will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"playerResolvable/","text":"PlayerResolvable PlayerResolvable simply allows you to get the username, userId, or Player Instance by any of the previous data. Installation Using Wally PlayerResolvable is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/playerResolvable@0.1.0\" wally install New to Wally? Read more about it . Requiring PlayerResolvable will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Usage First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local resolver = require ( game . ReplicatedStorage . Packages . PlayerResolvable ) Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local resolver = import \"@wally/playerResolvable\" The usage is pretty simple, only providing a total of three methods. Currently, the types of data it can resolve is limited to things that can be coerced into string or number and Player . 1 2 3 4 local username = resolver . getUsername ( 74909795 ) -- \"alexinite\" local userId = resolver . getUserId ( \"alexinite\" ) -- 74909795 local player = resolver . getPlayer ( \"alexinite\" ) -- if in-game, <Player> local player = resolver . getPlayer ( 74909795 ) -- if in-game, <Player>","title":"Introduction"},{"location":"playerResolvable/#playerresolvable","text":"PlayerResolvable simply allows you to get the username, userId, or Player Instance by any of the previous data.","title":"PlayerResolvable"},{"location":"playerResolvable/#installation","text":"","title":"Installation"},{"location":"playerResolvable/#using-wally","text":"PlayerResolvable is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/playerResolvable@0.1.0\" wally install New to Wally? Read more about it . Requiring PlayerResolvable will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"playerResolvable/#usage","text":"First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local resolver = require ( game . ReplicatedStorage . Packages . PlayerResolvable ) Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local resolver = import \"@wally/playerResolvable\" The usage is pretty simple, only providing a total of three methods. Currently, the types of data it can resolve is limited to things that can be coerced into string or number and Player . 1 2 3 4 local username = resolver . getUsername ( 74909795 ) -- \"alexinite\" local userId = resolver . getUserId ( \"alexinite\" ) -- 74909795 local player = resolver . getPlayer ( \"alexinite\" ) -- if in-game, <Player> local player = resolver . getPlayer ( 74909795 ) -- if in-game, <Player>","title":"Usage"},{"location":"switch-case/","text":"SwitchCase SwitchCase is an implementation of switch/case from JavaScript and other popular languages (like Java). It attempts to recreate it syntactically similar. However, doing this in Roblox is not easy due to how variables are encapsulated. Installation Using Wally SwitchCase is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SwitchCase = \"alexinite/switch-case@0.1.2\" wally install New to Wally? Read more about it . Requiring SwitchCase will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Usage First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local switch , case , default = require ( game . ReplicatedStorage . Packages . SwitchCase )() Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local switch , case , default = import \"@wally/switchCase\" () Using SwitchCase functions relatively like JavaScript's Switch-Case. Here's an example of them side-by-side: Luau JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local num = 6 switch ( num ) { case ( 2 ) ( function () print ( \"number was 2!\" ) end ), case ( 5 ) ( function () print ( \"number was 5!\" ) end ), default ( function () print ( \"number was actually \" .. num ) end ) } 1 2 3 4 5 6 7 let num = 6 switch ( num ) { case 2 : console . log ( \"number was 2!\" ) case 5 : console . log ( \"number was 5!\" ) default : console . log ( \"number was actually \" + num ) }","title":"Switch/Case"},{"location":"switch-case/#switchcase","text":"SwitchCase is an implementation of switch/case from JavaScript and other popular languages (like Java). It attempts to recreate it syntactically similar. However, doing this in Roblox is not easy due to how variables are encapsulated.","title":"SwitchCase"},{"location":"switch-case/#installation","text":"","title":"Installation"},{"location":"switch-case/#using-wally","text":"SwitchCase is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SwitchCase = \"alexinite/switch-case@0.1.2\" wally install New to Wally? Read more about it . Requiring SwitchCase will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"switch-case/#usage","text":"First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local switch , case , default = require ( game . ReplicatedStorage . Packages . SwitchCase )() Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local switch , case , default = import \"@wally/switchCase\" () Using SwitchCase functions relatively like JavaScript's Switch-Case. Here's an example of them side-by-side: Luau JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local num = 6 switch ( num ) { case ( 2 ) ( function () print ( \"number was 2!\" ) end ), case ( 5 ) ( function () print ( \"number was 5!\" ) end ), default ( function () print ( \"number was actually \" .. num ) end ) } 1 2 3 4 5 6 7 let num = 6 switch ( num ) { case 2 : console . log ( \"number was 2!\" ) case 5 : console . log ( \"number was 5!\" ) default : console . log ( \"number was actually \" + num ) }","title":"Usage"},{"location":"tableUtil/","text":"TableUtil TableUtil is an extremely simple utility package for tables. Installation Using Wally TableUtil is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/table-util@0.1.0\" wally install New to Wally? Read more about it . Requiring TableUtil will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Usage First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local util = require ( game . ReplicatedStorage . Packages . TableUtil ) Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local util = import \"@wally/tableUtil\" .shallowCopy(table, table?) returns table Shallow copies a table into a new table, returning the copy. Shallow copying is to copy a table only one level deep, any tables nested inside of the table will not be copied. Providing a second argument copy will allow you to start with an initial table . This essentially concats/merges it with the copy. local original = { 1 , 2 , 3 , 4 , { 5 , 6 , 7 }} local copy = util . shallowCopy ( original ) -- {1, 2, 3, 4, [table]} local initial_copy = { 10 , 11 } local copy = util . shallowCopy ( original , initial_copy ) -- {10, 11, 1, 2, 3, 4, [table]} .deepCopy(table, table?) returns table Deep copies a table into a new table, returning the copy. Deep copying is to copy a table at every single level, any and all tables nested inside of each other and this table will be copied. Providing a second argument copy will allow you to start with an initial table . This essentially concats/merges it with the copy. local original = { 1 , 2 , 3 , 4 , { 5 , 6 , 7 }} local copy = util . deepCopy ( original ) -- {1, 2, 3, 4, {5, 6, 7}} local initial_copy = { 10 , 11 } local copy = util . deepCopy ( original , initial_copy ) -- {10, 11, 1, 2, 3, 4, {5, 6, 7}} .stringify(table) returns string Turns a deep table into a parseable string, seperated by commas. local t = { 1 , 2 , 3 , 4 , { 5 , 6 , 7 }} print ( util . stringify ( t )) -- \"1,2,3,4,{5,6,7}\" .iterateString(string) returns string[] Turns a string into an iterable array. local str = \"hi!\" local t = util . iterateString ( str ) -- {\"h\", \"i\", \"!\"}","title":"Introduction"},{"location":"tableUtil/#tableutil","text":"TableUtil is an extremely simple utility package for tables.","title":"TableUtil"},{"location":"tableUtil/#installation","text":"","title":"Installation"},{"location":"tableUtil/#using-wally","text":"TableUtil is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/table-util@0.1.0\" wally install New to Wally? Read more about it . Requiring TableUtil will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"tableUtil/#usage","text":"First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local util = require ( game . ReplicatedStorage . Packages . TableUtil ) Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local util = import \"@wally/tableUtil\"","title":"Usage"},{"location":"tableUtil/#shallowcopytable-table","text":"returns table Shallow copies a table into a new table, returning the copy. Shallow copying is to copy a table only one level deep, any tables nested inside of the table will not be copied. Providing a second argument copy will allow you to start with an initial table . This essentially concats/merges it with the copy. local original = { 1 , 2 , 3 , 4 , { 5 , 6 , 7 }} local copy = util . shallowCopy ( original ) -- {1, 2, 3, 4, [table]} local initial_copy = { 10 , 11 } local copy = util . shallowCopy ( original , initial_copy ) -- {10, 11, 1, 2, 3, 4, [table]}","title":".shallowCopy(table, table?)"},{"location":"tableUtil/#deepcopytable-table","text":"returns table Deep copies a table into a new table, returning the copy. Deep copying is to copy a table at every single level, any and all tables nested inside of each other and this table will be copied. Providing a second argument copy will allow you to start with an initial table . This essentially concats/merges it with the copy. local original = { 1 , 2 , 3 , 4 , { 5 , 6 , 7 }} local copy = util . deepCopy ( original ) -- {1, 2, 3, 4, {5, 6, 7}} local initial_copy = { 10 , 11 } local copy = util . deepCopy ( original , initial_copy ) -- {10, 11, 1, 2, 3, 4, {5, 6, 7}}","title":".deepCopy(table, table?)"},{"location":"tableUtil/#stringifytable","text":"returns string Turns a deep table into a parseable string, seperated by commas. local t = { 1 , 2 , 3 , 4 , { 5 , 6 , 7 }} print ( util . stringify ( t )) -- \"1,2,3,4,{5,6,7}\"","title":".stringify(table)"},{"location":"tableUtil/#iteratestringstring","text":"returns string[] Turns a string into an iterable array. local str = \"hi!\" local t = util . iterateString ( str ) -- {\"h\", \"i\", \"!\"}","title":".iterateString(string)"},{"location":"tween/","text":"Tween Tween simply just extends on what Roblox defaultly provides with their TweenService. Installation Using Wally Tween is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/tween@0.1.0\" wally install New to Wally? Read more about it . Requiring Tween will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Usage First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local tween = require ( game . ReplicatedStorage . Packages . Tween ) Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local tween = import \"@wally/tween\" tween() returns Tween | Tween[] param object * Instance | Instance[] * -- The instance(s) being tweened param info * TweenInfo * param dict * table<string, any> * -- The given properties to be tweened to param auto? * boolean * -- Should the tween automatically play? param default? * table<string, any> * -- The properties to start with before tweening local part = Instance . new ( \"Part\" ) tween ( part , TweenInfo . new ( 2 ), { Position = Vector3 . new ( 0 , 5 , 0 ) -- elevates it 3 studs up }, true , { -- automatically plays the tween Position = Vector3 . new ( 0 , 2 , 0 ) -- start the tween at 2 studs up }). Completed (): Wait () -- even if it automatically plays the tween, it still returns it local otherPart = Instance . new ( \"Part\" ) local bigParts = tween ({ part , otherPart }, TweenInfo . new ( 2 ), { Size = Vector3 . new ( 3 , 3 , 3 ) -- makes both parts 3^3 }) bigParts : Play ()","title":"Introduction"},{"location":"tween/#tween","text":"Tween simply just extends on what Roblox defaultly provides with their TweenService.","title":"Tween"},{"location":"tween/#installation","text":"","title":"Installation"},{"location":"tween/#using-wally","text":"Tween is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] Logger = \"alexinite/tween@0.1.0\" wally install New to Wally? Read more about it . Requiring Tween will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"tween/#usage","text":"First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. local tween = require ( game . ReplicatedStorage . Packages . Tween ) Tip If you're using my Import Package , you can import it like this: local import = require ( game . ReplicatedStorage . Packages . Import ) local tween = import \"@wally/tween\"","title":"Usage"},{"location":"tween/#tween_1","text":"returns Tween | Tween[] param object * Instance | Instance[] * -- The instance(s) being tweened param info * TweenInfo * param dict * table<string, any> * -- The given properties to be tweened to param auto? * boolean * -- Should the tween automatically play? param default? * table<string, any> * -- The properties to start with before tweening local part = Instance . new ( \"Part\" ) tween ( part , TweenInfo . new ( 2 ), { Position = Vector3 . new ( 0 , 5 , 0 ) -- elevates it 3 studs up }, true , { -- automatically plays the tween Position = Vector3 . new ( 0 , 2 , 0 ) -- start the tween at 2 studs up }). Completed (): Wait () -- even if it automatically plays the tween, it still returns it local otherPart = Instance . new ( \"Part\" ) local bigParts = tween ({ part , otherPart }, TweenInfo . new ( 2 ), { Size = Vector3 . new ( 3 , 3 , 3 ) -- makes both parts 3^3 }) bigParts : Play ()","title":"tween()"}]}
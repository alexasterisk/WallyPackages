{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Collection of Wally Packages","text":""},{"location":"#classes","title":"Classes","text":""},{"location":"#v015-lua-objects","title":"<code>v0.1.5</code> lua-objects","text":""},{"location":"#utilities","title":"Utilities","text":""},{"location":"#v018-import","title":"<code>v0.1.8</code> import","text":""},{"location":"#v011-logger","title":"<code>v0.1.1</code> logger","text":""},{"location":"#v010-tween","title":"<code>v0.1.0</code> tween","text":""},{"location":"#internal-resources","title":"Internal Resources","text":""},{"location":"#v011-table-util","title":"<code>v0.1.1</code> table-util","text":""},{"location":"#v021-player-resolvable","title":"<code>v0.2.1</code> player-resolvable","text":""},{"location":"#hosted-packages","title":"Hosted Packages","text":""},{"location":"#v232-alexinitemaid","title":"<code>v2.3.2</code> alexinite/maid","text":"<p>This project belongs to Quenty.</p>"},{"location":"#v020-beta-alexinitefusion","title":"<code>v0.2.0-beta</code> alexinite/fusion","text":"<p>A version of Fusion which is kept relatively up-to-date with the primary fork. If you're looking for the beta version, ruizukun-dev hosts that <code>ruizukun-dev/fusion@1.0.0</code>. This project belongs to Elttob.</p>"},{"location":"import/","title":"Introduction","text":"<p>Impractical</p> <p>This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to.</p> <p>For starters, you'll need to know how to use Roblox Studio... ~and Luau~... Anyways, Import is a Require module like TypeScript's <code>import</code>.</p> SugarNo Sugar <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal import = require(ReplicatedStorage.Packages.Import)\n\nlocal SomeClass = import \"shared/someClass\"\n</code></pre> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal import = require(ReplicatedStorage.Packages.Import)\n\nlocal SomeClass = import(\"shared/someClass\")\n</code></pre>"},{"location":"import/#sugar-syntax","title":"Sugar Syntax","text":"<p>Due to Lua's weird sugar syntax rules when it comes to encapsulation: You can create this weird syntax which drives some people insane but I personally think it looks cool. This is inspired off of Elttob's Fusion module.</p>"},{"location":"import/installation/","title":"Installation","text":"<p>Impractical</p> <p>This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to.</p> <p>Installing Import is as simple as simple as I could've ever made it. It's necessary to install it via your prefered method.</p>"},{"location":"import/installation/#using-rojo","title":"Using Rojo","text":"<p>If you use Rojo, this is relatively easy by setting up your Rojo workflow like the following:</p> wally.toml<pre><code>[package]\nname = \"user/repo\"\ndescription = \"some maybe cool project\"\nversion = \"1.0.0\"\nregistry = \"https://github.com/UpliftGames/wally-index\"\nrealm = \"shared\"\n\n[dependencies]\nImport = \"alexinite/import@0.1.8\"\n</code></pre> default.project.json<pre><code>{\n\"name\": \"project-name\",\n\"tree\": {\n\"$className\": \"DataModel\",\n\"ReplicatedStorage\": {\n\"$path\": \"src/shared\",\n\"Packages\": {\n\"$path\": \"Packages\"\n},\n\"DevPackages\": {\n\"$path\": \"DevPackages\"\n}\n},\n\"ServerScriptService\": {\n\"$path\": \"src/server\",\n\"Packages\": {\n\"$path\": \"ServerPackages\"\n}\n}\n...\n}\n}\n</code></pre> <p>After that, you just have to run <code>wally install</code> in your project's directory.</p>"},{"location":"import/installation/#using-github","title":"Using GitHub","text":"<p>For those that use GitHub, you will to download the <code>.zip</code> file on the repository and copy the entire folder of <code>src/Import</code> into the <code>Packages</code> folder in ReplicatedStorage.</p>"},{"location":"import/usage/","title":"Usage","text":"<p>Impractical</p> <p>This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to.</p>"},{"location":"import/usage/#reference-points","title":"Reference Points","text":"<p>Referencing using <code>import</code> is in close parity with TypeScript's <code>import from</code> and formatted around Rojo's traditional workflow. It's also worth to note that the first letter of what you're requiring is interchangeable with uppercase and lowercase.</p>"},{"location":"import/usage/#wally-packages","title":"Wally Packages","text":"<p>When Importing packages from Wally, you will need your Rojo workflow to look like the following:</p> default.project.json<pre><code>{\n\"name\": \"project-name\",\n\"tree\": {\n\"$className\": \"DataModel\",\n\"ReplicatedStorage\": {\n\"$path\": \"src/shared\",\n\"Packages\": {\n\"$path\": \"Packages\"\n},\n\"DevPackages\": {\n\"$path\": \"DevPackages\"\n}\n},\n\"ServerScriptService\": {\n\"$path\": \"src/server\",\n\"Packages\": {\n\"$path\": \"ServerPackages\"\n}\n}\n...\n}\n}\n</code></pre> <p>Then, after installing with <code>wally install</code>, you can require a Wally package like this:</p> <p>Example<pre><code>local import = require(game.ReplicatedStorage.Packages.Import)\n\nlocal Maid = import \"@wally/maid\"\n</code></pre> </p> <p>Tip<p>If you're importing a dev-package or server-package, it can be done like this:</p> <pre><code>local devPackage = import \"@wally-dev/someDevPackage\"\nlocal serverPackage = import \"@wally-server/someServerPackage\"\n</code></pre> </p>"},{"location":"import/usage/#replicatedstorage","title":"ReplicatedStorage","text":"<p>Example<pre><code>local SomeClass = import \"shared/classModule\"\n</code></pre> </p>"},{"location":"import/usage/#starterplayerscripts","title":"StarterPlayerScripts","text":"<p>Example*.client.lua<pre><code>local SomeClass = import \"client/classModule\"\n</code></pre> </p> <p>Client-Only<p>Using <code>client/</code> can only be done in a client-sided context. Attempting to access it from a server-sided context will result in an error.</p> </p>"},{"location":"import/usage/#serverscriptservice","title":"ServerScriptService","text":"<p>Example*.server.lua<pre><code>local SomeClass = import \"server/classModule\"\n</code></pre> </p> <p>Server-Only<p>Using <code>server/</code> can only be done in a server-sided context. Attempting to access it from a client-sided context will result in an error.</p> </p>"},{"location":"import/usage/#dot-references","title":"Dot References","text":"<p>One thing to tackle with this project was allowing TypeScript's <code>./</code> and <code>../</code> to be available from all contexts. Mostly for use with submodules.</p> <p>Example<pre><code>local import = require(game.ReplicatedStorage.Packages.Import) (script)\n\nlocal SomeSubclass = import \"./subclass\"\nlocal ClassInSameDir = import \"../otherClass\"\n</code></pre> </p> <p>Don't forget to run <code>(script)</code><p>Forgetting <code>(script)</code> when requiring import in times where a dot reference is used will result in an error.</p> </p>"},{"location":"logger/","title":"Logger","text":"<p>Logger is typically an internal package I use with my other packages; however, I find it really useful to use.</p>"},{"location":"logger/#installation","title":"Installation","text":""},{"location":"logger/#using-wally","title":"Using Wally","text":"<p>Logger is available via Wally + Rojo workflow, installing it is as easy as the following:</p> wally.toml<pre><code>[package]\nname = \"user/repo\"\ndescription = \"some maybe cool project\"\nversion = \"1.0.0\"\nregistry = \"https://github.com/UpliftGames/wally-index\"\nrealm = \"shared\"\n\n[dependencies]\nLogger = \"alexinite/logger@0.1.2\"\n</code></pre> <pre><code>wally install\n</code></pre> <p>New to Wally? Read more about it.</p> <p>Requiring Logger will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples.</p> default.project.json<pre><code>{\n\"name\": \"project-name\",\n\"tree\": {\n\"$className\": \"DataModel\",\n\"ReplicatedStorage\": {\n\"$path\": \"src/shared\",\n\"Packages\": {\n\"$path\": \"Packages\"\n}\n},\n...\n}\n}\n</code></pre>"},{"location":"logger/#usage","title":"Usage","text":"<p>First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages.</p> <p>When requiring the Logger, the first function will provide the name of the file you're initiating the Logger with. This is useful so you know which file is logging what.</p> <pre><code>local logger = require(game.ReplicatedStorage.Packages.Logger) \"FileName\"\n</code></pre> <p>Trying to keep the Logger relatively similiar to Roblox's built-in, it functions almost identical. There is a key difference however: I introduced Python-like string formatting.</p> LuauPython <pre><code>local name = \"Johnny\"\n\nlogger.logf(\"Hello, {name}!\", { name })\n\nlogger.errf(\"There was an error! Due to {name}!\", { name })\n</code></pre> <pre><code>name = \"Johnny\"\nprint(f'Hello, {name}!')\n</code></pre> <p>Obviously, doing the variable encapsulation in Lua would only be possible if the variable was not localized. This will be touched on more in the Usage.</p> Luau Non-Localized <pre><code>local logger = require(\"path/to/logger\") \"fileName\"\nname = \"Johnny\"\n\nlogger.env.logf(\"Hello, {name}!\")\n</code></pre>"},{"location":"logger/usage/","title":"Usage","text":"<p>To get started, you will need to require the Logger package.</p> <p>Usage of <code>GETFENV()</code><p>Using <code>logger.env.</code> will use <code>getfenv()</code>! If you're afraid of breaking Luau optimizations, feel free to just use the default logger! This also applies to using <code>logger.format(\"string\", true)</code>.</p> </p> <pre><code>local logger = require(game.ReplicatedStorage.Packages.Logger) \"fileName\"\n</code></pre> <p>Tip<p>If you're using my Import package, you can import it like this:</p> <pre><code>local import = require(game.ReplicatedStorage.Packages.Import)\nlocal logger = import \"@wally/logger\" \"fileName\"\n</code></pre> </p>"},{"location":"logger/usage/#using-the-formatter","title":"Using the formatter","text":""},{"location":"logger/usage/#loggerformatstring-anyboolean-number","title":"<code>logger.format(string, any[]|boolean, number?)</code>","text":"<p>If you're just using the Logger for it's Python-like string formatting, you can simply use <code>logger.format()</code></p> LuauPython <pre><code>local name = \"Johnny\"\nlogger.format(\"Hello, {name}!\", { name }) --- \"Hello, Johnny!\"\n</code></pre> <pre><code>name = \"Johnny\"\nprint(f'Hello, {name}!')\n</code></pre>"},{"location":"logger/usage/#non-localized-variables","title":"Non-Localized Variables","text":"<p>Luau Optimizations</p> <p>By using <code>logger.format(string, true)</code> it will use <code>getfenv()</code> which currently breaks Luau optimizations!</p> <p>To make formatting almost identical to Python, I added a method which will use <code>getfenv()</code> to find your non-local variables.</p> <pre><code>name = \"Johnny\"\nlogger.format(\"Hello, {name}!\", true) -- \"Hello, Johnny!\"\n</code></pre> <p>These variables have to not be defined by <code>local</code> or else the formatter will not be able to find them.</p> <pre><code>local name = \"Johnny\"\nlogger.format(\"Hello, {name}!\", true) -- errors\n</code></pre>"},{"location":"logger/usage/#printing-a-message","title":"Printing a message","text":""},{"location":"logger/usage/#loggerlogstring","title":"<code>logger.log(string, ...)</code>","text":"<p>This simply prints a message, accepting varadic arguments to print as extra data.</p> <pre><code>logger.log(\"Hello from the Logger!\")\nlogger.log(\"Hello from varargs!\", \"Hi!\", \"How are you?\")\n</code></pre>"},{"location":"logger/usage/#loggerlogfstring-any","title":"<code>logger.logf(string, any[], ...)</code>","text":"<p>This prints a message but uses the built-in formatter. This will match Python formatting. Just like <code>logger.log</code> this will accept varadic arguments to print as extra data.</p> <pre><code>logger.logf(\"Hello from {name}!\", { \"Alex\" }) -- \"Hello from Alex!\"\nlogger.logf(\"Hello from {name} and {me}!\", { \"varargs\", \"Alex\" }, \"other data\") -- \"Hello from varargs and Alex!\", \"other data\"\n</code></pre> <p>However, I find this formatting pretty ugly and instead just a general replacement of the ugly <code>string.format</code> built-in function.</p>"},{"location":"logger/usage/#loggerenvlogfstring","title":"<code>logger.env.logf(string, ...)</code>","text":"<p>Luau Optimizations</p> <p>By using <code>logger.env.logf(string, ...)</code> it will use <code>getfenv()</code> which currently breaks Luau optimizations!</p> <p>To make logger almost identical to Python, this will use <code>getfenv()</code> to find the non-local variable you referenced. This also accepts varadic arguments like every other log method.</p> <pre><code>name = \"Johnny\"\nlogger.env.logf(\"Hello, {name}!\") -- \"Hello, Johnny!\"\nlogger.env.logf(\"Hello, {name}!\", \"other data\") -- \"Hello, Johnny!\" \"other data\"\n\nlocal location = \"Workspace\" -- has to be NOT local\nlogger.env.logf(\"Go to {location} please!\") -- errors\n</code></pre>"},{"location":"logger/usage/#printing-a-warning","title":"Printing a warning","text":""},{"location":"logger/usage/#loggerwarnstring","title":"<code>logger.warn(string, ...)</code>","text":"<p>This simply warns with a message, accepting varadic arguments to print as extra data.</p> <pre><code>logger.warn(\"This is a warning!\")\nlogger.warn(\"This is warning with extra data!\", \"More!\", \"So many warnings!\")\n</code></pre>"},{"location":"logger/usage/#loggerwarnfstring-any","title":"<code>logger.warnf(string, any[], ...)</code>","text":"<p>This warns a message but uses the built-in formatter. This will match Python formatting. Just like <code>logger.log</code> this will accept varadic arguments to print as extra data.</p> <pre><code>logger.warnf(\"Warning from {name}!\", { \"Alex\" }) -- \"Warning from Alex!\"\nlogger.warnf(\"Warning from {name} and {me}!\", { \"cause\", \"Alex\" }, \"other data\") -- \"Warning from cause and Alex!\", \"other data\"\n</code></pre>"},{"location":"logger/usage/#loggerenvwarnfstring","title":"<code>logger.env.warnf(string, ...)</code>","text":"<p>Luau Optimizations</p> <p>By using <code>logger.env.warnf(string, ...)</code> it will use <code>getfenv()</code> which currently breaks Luau optimizations!</p> <p>To make logger almost identical to Python, this will use <code>getfenv()</code> to find the non-local variable you referenced. This also accepts varadic arguments like every other warn method.</p> <pre><code>reason = \"it broke\"\nlogger.env.warnf(\"Warning! {reason}!\") -- \"Warning! it broke!\"\nlogger.env.warnf(\"Warning! {reason}!\", \"other data\") -- \"Warning! it broke!\" \"other data\"\n\nlocal location = \"Workspace\" -- has to be NOT local\nlogger.env.warnf(\"It was caused in {location}!\") -- errors\n</code></pre>"},{"location":"logger/usage/#throwing-an-error","title":"Throwing an error","text":""},{"location":"logger/usage/#loggererrstring-numberany","title":"<code>logger.err(string, number|any, ...)</code>","text":"<p>This simply will throw an error, accepting varadic arguments to print as extra data.</p> <p>If the first varadic argument is <code>typeof number</code>, it will be used instead as the error logging level.</p> <pre><code>logger.err(\"Oh no!\")\nlogger.err(\"Oh no!\", \"This occurred\") -- \"This occurred\" \"Oh no!\"\nlogger.err(\"Oh no!\", 3, \"This occurred\") -- \"This occurred\" \"Oh no!\"\n</code></pre>"},{"location":"logger/usage/#loggererrfstring-any-numberany","title":"<code>logger.errf(string, any[], number|any, ...)</code>","text":"<p>This will throw an error but will use the built-in formatter. This will match Python formatting. Just like <code>logger.err</code> this will accept varadic arguments to print as extra data and using the first varadic argument, if it is a number, as the error logging level.</p> <pre><code>local cause = \"bad B.O.\"\nlogger.errf(\"Oh no! {cause} broke the game!\", { cause }) -- \"Oh no! bad B.O. broke the game!\"\n</code></pre>"},{"location":"logger/usage/#loggerenverrfstring-numberany","title":"<code>logger.env.errf(string, number|any, ...)</code>","text":"<p>Luau Optimizations</p> <p>By using <code>logger.env.errf(string, number|any, ...)</code> it will use <code>getfenv()</code> which currently breaks Luau optimizations!</p> <p>To make logger almost identical to Python, this will use <code>getfenv()</code> to find the non-local variable you referenced. This also accepts varadic arguments and will use the first one as the error logging level if it as a number, just like every other err method.</p> <pre><code>cause = \"bad B.O.\"\nlogger.env.errf(\"Oh no! {cause} broke the game!\") -- \"Oh no! bad B.O. broke the game!\"\n\nlocal description = \"He really smelled\" -- has to be NOT local\nlogger.env.errf(\"Why did this happen? {description}\") --- errors\n</code></pre>"},{"location":"objects/","title":"LuaObjects (arrays-maps-sets)","text":"<p>LuaObjects is an extended version of LuaArray, implementing almost every feature from Arrays, Maps, and Sets from JavaScript.</p>"},{"location":"objects/#installation","title":"Installation","text":""},{"location":"objects/#using-wally","title":"Using Wally","text":"<p>LuaObjects is available via Wally + Rojo workflow, installing it is as easy as the following:</p> wally.toml<pre><code>[package]\nname = \"user/repo\"\ndescription = \"some maybe cool project\"\nversion = \"1.0.0\"\nregistry = \"https://github.com/UpliftGames/wally-index\"\nrealm = \"shared\"\n\n[dependencies]\nLogger = \"alexinite/arrays-maps-sets@0.1.5\"\n</code></pre> <pre><code>wally install\n</code></pre> <p>New to Wally? Read more about it.</p> <p>Requiring LuaObjects will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples.</p> default.project.json<pre><code>{\n\"name\": \"project-name\",\n\"tree\": {\n\"$className\": \"DataModel\",\n\"ReplicatedStorage\": {\n\"$path\": \"src/shared\",\n\"Packages\": {\n\"$path\": \"Packages\"\n}\n},\n...\n}\n}\n</code></pre>"},{"location":"playerResolvable/","title":"PlayerResolvable","text":"<p>PlayerResolvable simply allows you to get the username, userId, or Player Instance by any of the previous data.</p>"},{"location":"playerResolvable/#installation","title":"Installation","text":""},{"location":"playerResolvable/#using-wally","title":"Using Wally","text":"<p>PlayerResolvable is available via Wally + Rojo workflow, installing it is as easy as the following:</p> wally.toml<pre><code>[package]\nname = \"user/repo\"\ndescription = \"some maybe cool project\"\nversion = \"1.0.0\"\nregistry = \"https://github.com/UpliftGames/wally-index\"\nrealm = \"shared\"\n\n[dependencies]\nLogger = \"alexinite/playerResolvable@0.2.1\"\n</code></pre> <pre><code>wally install\n</code></pre> <p>New to Wally? Read more about it.</p> <p>Requiring PlayerResolvable will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples.</p> default.project.json<pre><code>{\n\"name\": \"project-name\",\n\"tree\": {\n\"$className\": \"DataModel\",\n\"ReplicatedStorage\": {\n\"$path\": \"src/shared\",\n\"Packages\": {\n\"$path\": \"Packages\"\n}\n},\n...\n}\n}\n</code></pre>"},{"location":"playerResolvable/#usage","title":"Usage","text":"<p>First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages.</p> <pre><code>local resolver = require(game.ReplicatedStorage.Packages.PlayerResolvable)\n</code></pre> <p>The usage is pretty simple, only providing a total of three methods. Currently, the types of data it can resolve is limited to things that can be coerced into <code>string</code> or <code>number</code> and <code>Player</code>.</p> <pre><code>local username = resolver.getUsername(74909795) -- \"alexinite\"\nlocal userId = resolver.getUserId(\"alexinite\") -- 74909795\nlocal player = resolver.getPlayer(\"alexinite\") -- if in-game, &lt;Player&gt;\nlocal player = resolver.getPlayer(74909795) -- if in-game, &lt;Player&gt;\n</code></pre>"},{"location":"table-util/","title":"TableUtil","text":"<p>TableUtil is an extremely simple utility package for tables.</p>"},{"location":"table-util/#installation","title":"Installation","text":""},{"location":"table-util/#using-wally","title":"Using Wally","text":"<p>TableUtil is available via Wally + Rojo workflow, installing it is as easy as the following:</p> wally.toml<pre><code>[package]\nname = \"user/repo\"\ndescription = \"some maybe cool project\"\nversion = \"1.0.0\"\nregistry = \"https://github.com/UpliftGames/wally-index\"\nrealm = \"shared\"\n\n[dependencies]\nTableUtil = \"alexinite/table-util@0.1.1\"\n</code></pre> <pre><code>wally install\n</code></pre> <p>New to Wally? Read more about it.</p> <p>Requiring TableUtil will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples.</p> default.project.json<pre><code>{\n\"name\": \"project-name\",\n\"tree\": {\n\"$className\": \"DataModel\",\n\"ReplicatedStorage\": {\n\"$path\": \"src/shared\",\n\"Packages\": {\n\"$path\": \"Packages\"\n}\n},\n...\n}\n}\n</code></pre>"},{"location":"table-util/#usage","title":"Usage","text":"<p>First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages.</p> <pre><code>local util = require(game.ReplicatedStorage.Packages.TableUtil)\n</code></pre>"},{"location":"table-util/#shallowcopytable-table","title":"<code>.shallowCopy(table, table?)</code>","text":"<ul> <li>returns <code>table</code></li> </ul> <p>Shallow copies a table into a new table, returning the copy. Shallow copying is to copy a table only one level deep, any tables nested inside of the table will not be copied.</p> <p>Providing a second argument <code>copy</code> will allow you to start with an initial table. This essentially concats/merges it with the copy.</p> <pre><code>local original = {1, 2, 3, 4, {5, 6, 7}}\nlocal copy = util.shallowCopy(original) -- {1, 2, 3, 4, [table]}\n\nlocal initial_copy = {10, 11}\nlocal copy = util.shallowCopy(original, initial_copy) -- {10, 11, 1, 2, 3, 4, [table]}\n</code></pre>"},{"location":"table-util/#deepcopytable-table","title":"<code>.deepCopy(table, table?)</code>","text":"<ul> <li>returns <code>table</code></li> </ul> <p>Deep copies a table into a new table, returning the copy. Deep copying is to copy a table at every single level, any and all tables nested inside of each other and this table will be copied.</p> <p>Providing a second argument <code>copy</code> will allow you to start with an initial table. This essentially concats/merges it with the copy.</p> <pre><code>local original = {1, 2, 3, 4, {5, 6, 7}}\nlocal copy = util.deepCopy(original) -- {1, 2, 3, 4, {5, 6, 7}}\n\nlocal initial_copy = {10, 11}\nlocal copy = util.deepCopy(original, initial_copy) -- {10, 11, 1, 2, 3, 4, {5, 6, 7}}\n</code></pre>"},{"location":"table-util/#stringifytable","title":"<code>.stringify(table)</code>","text":"<ul> <li>returns <code>string</code></li> </ul> <p>Turns a deep table into a parseable string, seperated by commas.</p> <pre><code>local t = {1, 2, 3, 4, {5, 6, 7}}\nprint(util.stringify(t)) -- \"1,2,3,4,{5,6,7}\"\n</code></pre>"},{"location":"table-util/#iteratestringstring","title":"<code>.iterateString(string)</code>","text":"<ul> <li>returns <code>string[]</code></li> </ul> <p>Turns a string into an iterable array.</p> <pre><code>local str = \"hi!\"\nlocal t = util.iterateString(str) -- {\"h\", \"i\", \"!\"}\n</code></pre>"},{"location":"tween/","title":"Tween","text":"<p>Tween simply just extends on what Roblox defaultly provides with their TweenService.</p>"},{"location":"tween/#installation","title":"Installation","text":""},{"location":"tween/#using-wally","title":"Using Wally","text":"<p>Tween is available via Wally + Rojo workflow, installing it is as easy as the following:</p> wally.toml<pre><code>[package]\nname = \"user/repo\"\ndescription = \"some maybe cool project\"\nversion = \"1.0.0\"\nregistry = \"https://github.com/UpliftGames/wally-index\"\nrealm = \"shared\"\n\n[dependencies]\nLogger = \"alexinite/tween@0.1.0\"\n</code></pre> <pre><code>wally install\n</code></pre> <p>New to Wally? Read more about it.</p> <p>Requiring Tween will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples.</p> default.project.json<pre><code>{\n\"name\": \"project-name\",\n\"tree\": {\n\"$className\": \"DataModel\",\n\"ReplicatedStorage\": {\n\"$path\": \"src/shared\",\n\"Packages\": {\n\"$path\": \"Packages\"\n}\n},\n...\n}\n}\n</code></pre>"},{"location":"tween/#usage","title":"Usage","text":"<p>First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages.</p> <pre><code>local tween = require(game.ReplicatedStorage.Packages.Tween)\n</code></pre>"},{"location":"tween/#tween_1","title":"tween()","text":"<ul> <li> <p>returns <code>Tween | Tween[]</code></p> </li> <li> <p>param object *<code>Instance | Instance[]</code>* -- The instance(s) being tweened</p> </li> <li>param info *<code>TweenInfo</code>*</li> <li>param dict *<code>table&lt;string, any&gt;</code>* -- The given properties to be tweened to</li> <li>param auto? *<code>boolean</code>* -- Should the tween automatically play?</li> <li>param default? *<code>table&lt;string, any&gt;</code>* -- The properties to start with before tweening</li> </ul> <pre><code>local part = Instance.new(\"Part\")\ntween(part, TweenInfo.new(2), {\n    Position = Vector3.new(0, 5, 0) -- elevates it 3 studs up\n}, true, { -- automatically plays the tween\n    Position = Vector3.new(0, 2, 0) -- start the tween at 2 studs up\n}).Completed():Wait()\n-- even if it automatically plays the tween, it still returns it\n\nlocal otherPart = Instance.new(\"Part\")\nlocal bigParts = tween({part, otherPart}, TweenInfo.new(2), {\n    Size = Vector3.new(3, 3, 3) -- makes both parts 3^3\n})\n\nbigParts:Play()\n</code></pre>"}]}
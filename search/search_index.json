{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Collection of Wally Packages Packages v0.1.1 import v0.1.0 switch-case v2.3.1 quenty/maid","title":"Home"},{"location":"#collection-of-wally-packages","text":"","title":"Collection of Wally Packages"},{"location":"#packages","text":"v0.1.1 import v0.1.0 switch-case v2.3.1 quenty/maid","title":"Packages"},{"location":"import/","text":"Introduction Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . For starters, you'll need to know how to use Roblox Studio... ~and Luau~... Anyways, Import is a Require module like TypeScript's import . Sugar No Sugar local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"shared/someClass\" local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import ( \"shared/someClass\" ) Sugar Syntax Due to Lua's weird sugar syntax rules when it comes to encapsulation: You can create this weird syntax which drives some people insane but I personally think it looks cool. This is inspired off of Elttob's Fusion module .","title":"Introduction"},{"location":"import/#introduction","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . For starters, you'll need to know how to use Roblox Studio... ~and Luau~... Anyways, Import is a Require module like TypeScript's import . Sugar No Sugar local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"shared/someClass\" local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import ( \"shared/someClass\" )","title":"Introduction"},{"location":"import/#sugar-syntax","text":"Due to Lua's weird sugar syntax rules when it comes to encapsulation: You can create this weird syntax which drives some people insane but I personally think it looks cool. This is inspired off of Elttob's Fusion module .","title":"Sugar Syntax"},{"location":"import/installation/","text":"Installation Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Installing Import is as simple as simple as I could've ever made it. It's necessary to install it via your prefered method. Using Rojo If you use Rojo, this is relatively easy by setting up your Rojo workflow like the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SomeRandomPackage = \"notAlex/notImport@1.0.0\" Import = \"alexinite/import@0.1.1\" default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } } } } After that, you just have to run wally install in your project's directory. Using GitHub For those that use GitHub, you will to download the .zip file on the repository and copy the entire folder of src/Import into the Packages folder in ReplicatedStorage.","title":"Installation"},{"location":"import/installation/#installation","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Installing Import is as simple as simple as I could've ever made it. It's necessary to install it via your prefered method.","title":"Installation"},{"location":"import/installation/#using-rojo","text":"If you use Rojo, this is relatively easy by setting up your Rojo workflow like the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SomeRandomPackage = \"notAlex/notImport@1.0.0\" Import = \"alexinite/import@0.1.1\" default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } } } } After that, you just have to run wally install in your project's directory.","title":"Using Rojo"},{"location":"import/installation/#using-github","text":"For those that use GitHub, you will to download the .zip file on the repository and copy the entire folder of src/Import into the Packages folder in ReplicatedStorage.","title":"Using GitHub"},{"location":"import/usage/","text":"Usage Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to . Reference Points Referencing using import is in close parity with TypeScript's import from and formatted around Rojo's traditional workflow. It's also worth to note that the first letter of what you're requiring is interchangeable with uppercase and lowercase. Wally Packages When Importing packages from Wally, you will need your Rojo workflow to look like the following: default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Then, after installing with wally install , you can require a Wally package like this: Example 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local Maid = import \"@wally/maid\" ReplicatedStorage Example 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"shared/classModule\" StarterPlayerScripts Example *.client.lua 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"client/classModule\" Client-Only Using client/ can only be done in a client-sided context. Attempting to access it from a server-sided context will result in an error. ServerScriptService Example *.server.lua 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"server/classModule\" Server-Only Using server/ can only be done in a server-sided context. Attempting to access it from a client-sided context will result in an error. Dot References One thing to tackle with this project was allowing TypeScript's ./ and ../ to be available from all contexts. Mostly for use with submodules. Example 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) [ script ] local SomeSubclass = import \"./subclass\" 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) [ script ] local ClassInSameDir = import \"../otherClass\" Don't forget to set [script] Forgetting [script] when requiring import in times where a dot reference is used will result in an error. Table and Function Back Referencing Whenever you require a Module you lose the ability to access the ModuleScript as an Instance without reusing the same location. Here is an example ModuleScript: Example shared/Multiply.lua 1 2 3 return function ( x : number , y : number ) return x * y end Now, this is a comparison of how you would back reference in Import and Roblox's default Require: Import Require 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local multiply = import \"shared/multiply\" -- first letter can be lowercase for consistency print ( multiply ( 5 * 3 )) -- prints 15 print ( multiply : GetFullName ()) -- \"game.ReplicatedStorage.Multipy\" 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local multiplyInstance = ReplicatedStorage . Mulitply local multiply = require ( multiplyInstance ) print ( multiply ( 5 * 3 )) -- prints 15 print ( multiplyInstance : GetFullName ()) -- \"game.ReplicatedStorage.Multiply\" This is also similar for tables/metatables kind of . Example shared/RandomClass.lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local class = {} class . __index = class function class . new ( x : number ) return setmetatable ({ number = x }, class ) end function class : multiplyBy ( y : number ) return self . number * y end return class 1 2 3 4 5 6 7 8 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local RandomClass = import \"shared/randomClass\" local randomClass = RandomClass . new ( 5 ) print ( randomClass : multiplyBy ( 3 )) -- prints 15 print ( randomClass . importBackRef : GetFullName ()) -- \"game.ReplicatedStorage.RandomClass\" Referencing Instances Sometimes what you're searching for doesn't need to be a script. Like the following: Example shared/part.model.json { \"ClassName\" : \"Part\" , \"Children\" : [{ \"Name\" : \"Head\" , \"ClassName\" : \"Part\" }], \"Properties\" : { \"Anchored\" : true } } 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local part = import \"shared/part\" print ( part . Head : GetFullName ()) -- \"game.ReplicatedStorage.part.Head\" Severely Impractical The implications of using Import like this is more impractical than using Import itself: which is impractical. You really needed me to tell you that?","title":"Usage"},{"location":"import/usage/#usage","text":"Impractical This module was more as a concept and doesn't give ANY speed bonuses to using the default require(); however, I'd argue it still looks better. If you'd like to make this more efficient please feel free to .","title":"Usage"},{"location":"import/usage/#reference-points","text":"Referencing using import is in close parity with TypeScript's import from and formatted around Rojo's traditional workflow. It's also worth to note that the first letter of what you're requiring is interchangeable with uppercase and lowercase.","title":"Reference Points"},{"location":"import/usage/#wally-packages","text":"When Importing packages from Wally, you will need your Rojo workflow to look like the following: default.project.json 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Then, after installing with wally install , you can require a Wally package like this: Example 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local Maid = import \"@wally/maid\"","title":"Wally Packages"},{"location":"import/usage/#replicatedstorage","text":"Example 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"shared/classModule\"","title":"ReplicatedStorage"},{"location":"import/usage/#starterplayerscripts","text":"Example *.client.lua 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"client/classModule\" Client-Only Using client/ can only be done in a client-sided context. Attempting to access it from a server-sided context will result in an error.","title":"StarterPlayerScripts"},{"location":"import/usage/#serverscriptservice","text":"Example *.server.lua 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local SomeClass = import \"server/classModule\" Server-Only Using server/ can only be done in a server-sided context. Attempting to access it from a client-sided context will result in an error.","title":"ServerScriptService"},{"location":"import/usage/#dot-references","text":"One thing to tackle with this project was allowing TypeScript's ./ and ../ to be available from all contexts. Mostly for use with submodules. Example 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) [ script ] local SomeSubclass = import \"./subclass\" 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) [ script ] local ClassInSameDir = import \"../otherClass\" Don't forget to set [script] Forgetting [script] when requiring import in times where a dot reference is used will result in an error.","title":"Dot References"},{"location":"import/usage/#table-and-function-back-referencing","text":"Whenever you require a Module you lose the ability to access the ModuleScript as an Instance without reusing the same location. Here is an example ModuleScript: Example shared/Multiply.lua 1 2 3 return function ( x : number , y : number ) return x * y end Now, this is a comparison of how you would back reference in Import and Roblox's default Require: Import Require 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local multiply = import \"shared/multiply\" -- first letter can be lowercase for consistency print ( multiply ( 5 * 3 )) -- prints 15 print ( multiply : GetFullName ()) -- \"game.ReplicatedStorage.Multipy\" 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local multiplyInstance = ReplicatedStorage . Mulitply local multiply = require ( multiplyInstance ) print ( multiply ( 5 * 3 )) -- prints 15 print ( multiplyInstance : GetFullName ()) -- \"game.ReplicatedStorage.Multiply\" This is also similar for tables/metatables kind of . Example shared/RandomClass.lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local class = {} class . __index = class function class . new ( x : number ) return setmetatable ({ number = x }, class ) end function class : multiplyBy ( y : number ) return self . number * y end return class 1 2 3 4 5 6 7 8 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local RandomClass = import \"shared/randomClass\" local randomClass = RandomClass . new ( 5 ) print ( randomClass : multiplyBy ( 3 )) -- prints 15 print ( randomClass . importBackRef : GetFullName ()) -- \"game.ReplicatedStorage.RandomClass\"","title":"Table and Function Back Referencing"},{"location":"import/usage/#referencing-instances","text":"Sometimes what you're searching for doesn't need to be a script. Like the following: Example shared/part.model.json { \"ClassName\" : \"Part\" , \"Children\" : [{ \"Name\" : \"Head\" , \"ClassName\" : \"Part\" }], \"Properties\" : { \"Anchored\" : true } } 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local import = require ( ReplicatedStorage . Packages . Import ) local part = import \"shared/part\" print ( part . Head : GetFullName ()) -- \"game.ReplicatedStorage.part.Head\" Severely Impractical The implications of using Import like this is more impractical than using Import itself: which is impractical. You really needed me to tell you that?","title":"Referencing Instances"},{"location":"switchcase/","text":"SwitchCase SwitchCase is an implementation of switch/case from JavaScript and other popular languages (like Java). It attempts to recreate it syntactically similar. However, doing this in Roblox is not easy due to how variables are encapsulated. Installation Using Wally SwitchCase is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SwitchCase = \"alexinite/switch-case@0.1.0\" wally install New to Wally? Read more about it . Requiring SwitchCase will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } } Usage First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local switch , case , default = require ( ReplicatedStorage . Packages . SwitchCase )() Tip If you're using my Import Package , you can import it like this: 1 2 local import = require ( ReplicatedStorage . Packages . Import ) local switch , case , default = import \"@wally/switchCase\" () Using SwitchCase functions relatively like JavaScript's Switch-Case. Here's an example of them side-by-side: Luau JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local num = 6 switch ( num ) { case ( 2 ) ( function () print ( \"number was 2!\" ) end ), case ( 5 ) ( function () print ( \"number was 5!\" ) end ), default ( function () print ( \"number was actually \" .. num ) end ) } 1 2 3 4 5 6 7 let num = 6 switch ( num ) { case 2 : console . log ( \"number was 2!\" ) case 5 : console . log ( \"number was 5!\" ) default : console . log ( \"number was actually \" + num ) }","title":"SwitchCase"},{"location":"switchcase/#switchcase","text":"SwitchCase is an implementation of switch/case from JavaScript and other popular languages (like Java). It attempts to recreate it syntactically similar. However, doing this in Roblox is not easy due to how variables are encapsulated.","title":"SwitchCase"},{"location":"switchcase/#installation","text":"","title":"Installation"},{"location":"switchcase/#using-wally","text":"SwitchCase is available via Wally + Rojo workflow, installing it is as easy as the following: wally.toml [package] name = \"user/repo\" description = \"some maybe cool project\" version = \"1.0.0\" registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] SwitchCase = \"alexinite/switch-case@0.1.0\" wally install New to Wally? Read more about it . Requiring SwitchCase will depend on your Rojo project format, I will assume you have Wally Packages going into ReplicatedStorage/Packages for usage examples. default.project.json { \"name\" : \"project-name\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$path\" : \"src/shared\" , \"Packages\" : { \"$path\" : \"Packages\" } }, ... } }","title":"Using Wally"},{"location":"switchcase/#usage","text":"First, requiring it depends on your Rojo project format, I will assume you have Wally Packages go into ReplicatedStorage/Packages. 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local switch , case , default = require ( ReplicatedStorage . Packages . SwitchCase )() Tip If you're using my Import Package , you can import it like this: 1 2 local import = require ( ReplicatedStorage . Packages . Import ) local switch , case , default = import \"@wally/switchCase\" () Using SwitchCase functions relatively like JavaScript's Switch-Case. Here's an example of them side-by-side: Luau JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local num = 6 switch ( num ) { case ( 2 ) ( function () print ( \"number was 2!\" ) end ), case ( 5 ) ( function () print ( \"number was 5!\" ) end ), default ( function () print ( \"number was actually \" .. num ) end ) } 1 2 3 4 5 6 7 let num = 6 switch ( num ) { case 2 : console . log ( \"number was 2!\" ) case 5 : console . log ( \"number was 5!\" ) default : console . log ( \"number was actually \" + num ) }","title":"Usage"}]}